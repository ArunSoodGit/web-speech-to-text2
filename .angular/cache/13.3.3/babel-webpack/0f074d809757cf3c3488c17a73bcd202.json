{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { MessageType, TranslationStatus } from \"../common/Exports\";\nimport { CancellationErrorCode, CancellationReason, PropertyCollection, PropertyId, ResultReason, TranslationRecognitionCanceledEventArgs, TranslationRecognitionEventArgs, TranslationRecognitionResult, Translations, TranslationSynthesisEventArgs, TranslationSynthesisResult } from \"../sdk/Exports\";\nimport { CancellationErrorCodePropertyName, EnumTranslation, RecognitionStatus, ServiceRecognizerBase, SynthesisStatus, TranslationHypothesis, TranslationPhrase, TranslationSynthesisEnd } from \"./Exports\"; // eslint-disable-next-line max-classes-per-file\n\nexport class TranslationServiceRecognizer extends ServiceRecognizerBase {\n  constructor(authentication, connectionFactory, audioSource, recognizerConfig, translationRecognizer) {\n    super(authentication, connectionFactory, audioSource, recognizerConfig, translationRecognizer);\n    this.privTranslationRecognizer = translationRecognizer;\n    this.connectionEvents.attach(connectionEvent => {\n      if (connectionEvent.name === \"ConnectionEstablishedEvent\") {\n        this.privTranslationRecognizer.onConnection();\n      } else if (connectionEvent.name === \"ConnectionClosedEvent\") {\n        void this.privTranslationRecognizer.onDisconnection();\n      }\n    });\n  }\n\n  processTypeSpecificMessages(connectionMessage) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const resultProps = new PropertyCollection();\n      let processed = false;\n\n      const handleTranslationPhrase = translatedPhrase => __awaiter(this, void 0, void 0, function* () {\n        this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + translatedPhrase.Offset + translatedPhrase.Duration);\n\n        if (translatedPhrase.RecognitionStatus === RecognitionStatus.Success) {\n          // OK, the recognition was successful. How'd the translation do?\n          const result = this.fireEventForResult(translatedPhrase, resultProps);\n\n          if (!!this.privTranslationRecognizer.recognized) {\n            try {\n              this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, result);\n              /* eslint-disable no-empty */\n            } catch (error) {// Not going to let errors in the event handler\n              // trip things up.\n            }\n          } // report result to promise.\n\n\n          if (!!this.privSuccessCallback) {\n            try {\n              this.privSuccessCallback(result.result);\n            } catch (e) {\n              if (!!this.privErrorCallback) {\n                this.privErrorCallback(e);\n              }\n            } // Only invoke the call back once.\n            // and if it's successful don't invoke the\n            // error after that.\n\n\n            this.privSuccessCallback = undefined;\n            this.privErrorCallback = undefined;\n          }\n        } else {\n          const reason = EnumTranslation.implTranslateRecognitionResult(translatedPhrase.RecognitionStatus);\n          const result = new TranslationRecognitionResult(undefined, this.privRequestSession.requestId, reason, translatedPhrase.Text, translatedPhrase.Duration, this.privRequestSession.currentTurnAudioOffset + translatedPhrase.Offset, undefined, connectionMessage.textBody, resultProps);\n\n          if (reason === ResultReason.Canceled) {\n            const cancelReason = EnumTranslation.implTranslateCancelResult(translatedPhrase.RecognitionStatus);\n            const cancellationErrorCode = EnumTranslation.implTranslateCancelErrorCode(translatedPhrase.RecognitionStatus);\n            yield this.cancelRecognitionLocal(cancelReason, cancellationErrorCode, EnumTranslation.implTranslateErrorDetails(cancellationErrorCode));\n          } else {\n            if (!(this.privRequestSession.isSpeechEnded && reason === ResultReason.NoMatch && translatedPhrase.RecognitionStatus !== RecognitionStatus.InitialSilenceTimeout)) {\n              const ev = new TranslationRecognitionEventArgs(result, result.offset, this.privRequestSession.sessionId);\n\n              if (!!this.privTranslationRecognizer.recognized) {\n                try {\n                  this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, ev);\n                  /* eslint-disable no-empty */\n                } catch (error) {// Not going to let errors in the event handler\n                  // trip things up.\n                }\n              }\n            } // report result to promise.\n\n\n            if (!!this.privSuccessCallback) {\n              try {\n                this.privSuccessCallback(result);\n              } catch (e) {\n                if (!!this.privErrorCallback) {\n                  this.privErrorCallback(e);\n                }\n              } // Only invoke the call back once.\n              // and if it's successful don't invoke the\n              // error after that.\n\n\n              this.privSuccessCallback = undefined;\n              this.privErrorCallback = undefined;\n            }\n          }\n\n          processed = true;\n        }\n      });\n\n      if (connectionMessage.messageType === MessageType.Text) {\n        resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\n      }\n\n      switch (connectionMessage.path.toLowerCase()) {\n        case \"translation.hypothesis\":\n          const result = this.fireEventForResult(TranslationHypothesis.fromJSON(connectionMessage.textBody), resultProps);\n          this.privRequestSession.onHypothesis(this.privRequestSession.currentTurnAudioOffset + result.offset);\n\n          if (!!this.privTranslationRecognizer.recognizing) {\n            try {\n              this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, result);\n              /* eslint-disable no-empty */\n            } catch (error) {// Not going to let errors in the event handler\n              // trip things up.\n            }\n          }\n\n          processed = true;\n          break;\n\n        case \"translation.response\":\n          const phrase = JSON.parse(connectionMessage.textBody);\n\n          if (!!phrase.SpeechPhrase) {\n            yield handleTranslationPhrase(TranslationPhrase.fromTranslationResponse(phrase));\n          }\n\n          break;\n\n        case \"translation.phrase\":\n          yield handleTranslationPhrase(TranslationPhrase.fromJSON(connectionMessage.textBody));\n          break;\n\n        case \"translation.synthesis\":\n          this.sendSynthesisAudio(connectionMessage.binaryBody, this.privRequestSession.sessionId);\n          processed = true;\n          break;\n\n        case \"translation.synthesis.end\":\n          const synthEnd = TranslationSynthesisEnd.fromJSON(connectionMessage.textBody);\n\n          switch (synthEnd.SynthesisStatus) {\n            case SynthesisStatus.Error:\n              if (!!this.privTranslationRecognizer.synthesizing) {\n                const result = new TranslationSynthesisResult(ResultReason.Canceled, undefined);\n                const retEvent = new TranslationSynthesisEventArgs(result, this.privRequestSession.sessionId);\n\n                try {\n                  this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, retEvent);\n                  /* eslint-disable no-empty */\n                } catch (error) {// Not going to let errors in the event handler\n                  // trip things up.\n                }\n              }\n\n              if (!!this.privTranslationRecognizer.canceled) {\n                // And raise a canceled event to send the rich(er) error message back.\n                const canceledResult = new TranslationRecognitionCanceledEventArgs(this.privRequestSession.sessionId, CancellationReason.Error, synthEnd.FailureReason, CancellationErrorCode.ServiceError, null);\n\n                try {\n                  this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, canceledResult);\n                  /* eslint-disable no-empty */\n                } catch (error) {// Not going to let errors in the event handler\n                  // trip things up.\n                }\n              }\n\n              break;\n\n            case SynthesisStatus.Success:\n              this.sendSynthesisAudio(undefined, this.privRequestSession.sessionId);\n              break;\n\n            default:\n              break;\n          }\n\n          processed = true;\n          break;\n\n        default:\n          break;\n      }\n\n      return processed;\n    });\n  } // Cancels recognition.\n\n\n  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n    const properties = new PropertyCollection();\n    properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\n\n    if (!!this.privTranslationRecognizer.canceled) {\n      const cancelEvent = new TranslationRecognitionCanceledEventArgs(sessionId, cancellationReason, error, errorCode, undefined);\n\n      try {\n        this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, cancelEvent);\n        /* eslint-disable no-empty */\n      } catch (_a) {}\n    }\n\n    if (!!this.privSuccessCallback) {\n      const result = new TranslationRecognitionResult(undefined, // Translations\n      requestId, ResultReason.Canceled, undefined, // Text\n      undefined, // Druation\n      undefined, // Offset\n      error, undefined, // Json\n      properties);\n\n      try {\n        this.privSuccessCallback(result);\n        /* eslint-disable no-empty */\n\n        this.privSuccessCallback = undefined;\n      } catch (_b) {}\n    }\n  }\n\n  fireEventForResult(serviceResult, properties) {\n    let translations;\n\n    if (undefined !== serviceResult.Translation.Translations) {\n      translations = new Translations();\n\n      for (const translation of serviceResult.Translation.Translations) {\n        translations.set(translation.Language, translation.Text || translation.DisplayText);\n      }\n    }\n\n    let resultReason;\n\n    if (serviceResult instanceof TranslationPhrase) {\n      if (serviceResult.Translation.TranslationStatus === TranslationStatus.Success) {\n        resultReason = ResultReason.TranslatedSpeech;\n      } else {\n        resultReason = ResultReason.RecognizedSpeech;\n      }\n    } else {\n      resultReason = ResultReason.TranslatingSpeech;\n    }\n\n    const offset = serviceResult.Offset + this.privRequestSession.currentTurnAudioOffset;\n    const result = new TranslationRecognitionResult(translations, this.privRequestSession.requestId, resultReason, serviceResult.Text, serviceResult.Duration, offset, serviceResult.Translation.FailureReason, JSON.stringify(serviceResult), properties);\n    const ev = new TranslationRecognitionEventArgs(result, offset, this.privRequestSession.sessionId);\n    return ev;\n  }\n\n  sendSynthesisAudio(audio, sessionId) {\n    const reason = undefined === audio ? ResultReason.SynthesizingAudioCompleted : ResultReason.SynthesizingAudio;\n    const result = new TranslationSynthesisResult(reason, audio);\n    const retEvent = new TranslationSynthesisEventArgs(result, sessionId);\n\n    if (!!this.privTranslationRecognizer.synthesizing) {\n      try {\n        this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, retEvent);\n        /* eslint-disable no-empty */\n      } catch (error) {// Not going to let errors in the event handler\n        // trip things up.\n      }\n    }\n  }\n\n} //# sourceMappingURL=TranslationServiceRecognizer.js.map","map":null,"metadata":{},"sourceType":"module"}