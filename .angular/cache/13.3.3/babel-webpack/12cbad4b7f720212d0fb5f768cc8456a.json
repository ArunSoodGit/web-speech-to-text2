{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/* eslint-disable max-classes-per-file */\n\n\nimport { connectivity, type } from \"../../common.speech/Exports\";\nimport { AudioSourceInitializingEvent, AudioSourceReadyEvent, AudioStreamNodeAttachedEvent, AudioStreamNodeAttachingEvent, AudioStreamNodeDetachedEvent, ChunkedArrayBufferStream, Events, EventSource } from \"../../common/Exports\";\nimport { createNoDashGuid } from \"../../common/Guid\";\nimport { AudioStreamFormat } from \"../Exports\";\nimport { AudioStreamFormatImpl } from \"./AudioStreamFormat\";\n/**\n * Represents audio input stream used for custom audio input configurations.\n * @class AudioInputStream\n */\n\nexport class AudioInputStream {\n  /**\n   * Creates and initializes an instance.\n   * @constructor\n   */\n  constructor() {\n    return;\n  }\n  /**\n   * Creates a memory backed PushAudioInputStream with the specified audio format.\n   * @member AudioInputStream.createPushStream\n   * @function\n   * @public\n   * @param {AudioStreamFormat} format - The audio data format in which audio will be\n   * written to the push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).\n   * @returns {PushAudioInputStream} The audio input stream being created.\n   */\n\n\n  static createPushStream(format) {\n    return PushAudioInputStream.create(format);\n  }\n  /**\n   * Creates a PullAudioInputStream that delegates to the specified callback interface for read()\n   * and close() methods.\n   * @member AudioInputStream.createPullStream\n   * @function\n   * @public\n   * @param {PullAudioInputStreamCallback} callback - The custom audio input object, derived from\n   * PullAudioInputStreamCallback\n   * @param {AudioStreamFormat} format - The audio data format in which audio will be returned from\n   * the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).\n   * @returns {PullAudioInputStream} The audio input stream being created.\n   */\n\n\n  static createPullStream(callback, format) {\n    return PullAudioInputStream.create(callback, format); // throw new Error(\"Oops\");\n  }\n\n}\n/**\n * Represents memory backed push audio input stream used for custom audio input configurations.\n * @class PushAudioInputStream\n */\n\nexport class PushAudioInputStream extends AudioInputStream {\n  /**\n   * Creates a memory backed PushAudioInputStream with the specified audio format.\n   * @member PushAudioInputStream.create\n   * @function\n   * @public\n   * @param {AudioStreamFormat} format - The audio data format in which audio will be written to the\n   * push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).\n   * @returns {PushAudioInputStream} The push audio input stream being created.\n   */\n  static create(format) {\n    return new PushAudioInputStreamImpl(format);\n  }\n\n}\n/**\n * Represents memory backed push audio input stream used for custom audio input configurations.\n * @private\n * @class PushAudioInputStreamImpl\n */\n\nexport class PushAudioInputStreamImpl extends PushAudioInputStream {\n  /**\n   * Creates and initalizes an instance with the given values.\n   * @constructor\n   * @param {AudioStreamFormat} format - The audio stream format.\n   */\n  constructor(format) {\n    super();\n\n    if (format === undefined) {\n      this.privFormat = AudioStreamFormatImpl.getDefaultInputFormat();\n    } else {\n      this.privFormat = format;\n    }\n\n    this.privEvents = new EventSource();\n    this.privId = createNoDashGuid();\n    this.privStream = new ChunkedArrayBufferStream(this.privFormat.avgBytesPerSec / 10);\n  }\n  /**\n   * Format information for the audio\n   */\n\n\n  get format() {\n    return Promise.resolve(this.privFormat);\n  }\n  /**\n   * Writes the audio data specified by making an internal copy of the data.\n   * @member PushAudioInputStreamImpl.prototype.write\n   * @function\n   * @public\n   * @param {ArrayBuffer} dataBuffer - The audio buffer of which this function will make a copy.\n   */\n\n\n  write(dataBuffer) {\n    this.privStream.writeStreamChunk({\n      buffer: dataBuffer,\n      isEnd: false,\n      timeReceived: Date.now()\n    });\n  }\n  /**\n   * Closes the stream.\n   * @member PushAudioInputStreamImpl.prototype.close\n   * @function\n   * @public\n   */\n\n\n  close() {\n    this.privStream.close();\n  }\n\n  id() {\n    return this.privId;\n  }\n\n  get blob() {\n    return this.attach(\"id\").then(audioNode => {\n      const data = [];\n      let bufferData = Buffer.from(\"\");\n\n      const readCycle = () => audioNode.read().then(audioStreamChunk => {\n        if (!audioStreamChunk || audioStreamChunk.isEnd) {\n          if (typeof XMLHttpRequest !== \"undefined\" && typeof Blob !== \"undefined\") {\n            return Promise.resolve(new Blob(data));\n          } else {\n            return Promise.resolve(Buffer.from(bufferData));\n          }\n        } else {\n          if (typeof Blob !== \"undefined\") {\n            data.push(audioStreamChunk.buffer);\n          } else {\n            bufferData = Buffer.concat([bufferData, this.toBuffer(audioStreamChunk.buffer)]);\n          }\n\n          return readCycle();\n        }\n      });\n\n      return readCycle();\n    });\n  }\n\n  turnOn() {\n    this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\n\n    this.onEvent(new AudioSourceReadyEvent(this.privId));\n    return;\n  }\n\n  attach(audioNodeId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\n      yield this.turnOn();\n      const stream = this.privStream;\n      this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\n      return {\n        detach: () => __awaiter(this, void 0, void 0, function* () {\n          this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n          return this.turnOff();\n        }),\n        id: () => audioNodeId,\n        read: () => stream.read()\n      };\n    });\n  }\n\n  detach(audioNodeId) {\n    this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n  }\n\n  turnOff() {\n    return;\n  }\n\n  get events() {\n    return this.privEvents;\n  }\n\n  get deviceInfo() {\n    return Promise.resolve({\n      bitspersample: this.privFormat.bitsPerSample,\n      channelcount: this.privFormat.channels,\n      connectivity: connectivity.Unknown,\n      manufacturer: \"Speech SDK\",\n      model: \"PushStream\",\n      samplerate: this.privFormat.samplesPerSec,\n      type: type.Stream\n    });\n  }\n\n  onEvent(event) {\n    this.privEvents.onEvent(event);\n    Events.instance.onEvent(event);\n  }\n\n  toBuffer(arrayBuffer) {\n    const buf = Buffer.alloc(arrayBuffer.byteLength);\n    const view = new Uint8Array(arrayBuffer);\n\n    for (let i = 0; i < buf.length; ++i) {\n      buf[i] = view[i];\n    }\n\n    return buf;\n  }\n\n}\n/*\n * Represents audio input stream used for custom audio input configurations.\n * @class PullAudioInputStream\n */\n\nexport class PullAudioInputStream extends AudioInputStream {\n  /**\n   * Creates and initializes and instance.\n   * @constructor\n   */\n  constructor() {\n    super();\n  }\n  /**\n   * Creates a PullAudioInputStream that delegates to the specified callback interface for\n   * read() and close() methods, using the default format (16 kHz 16bit mono PCM).\n   * @member PullAudioInputStream.create\n   * @function\n   * @public\n   * @param {PullAudioInputStreamCallback} callback - The custom audio input object,\n   * derived from PullAudioInputStreamCustomCallback\n   * @param {AudioStreamFormat} format - The audio data format in which audio will be\n   * returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).\n   * @returns {PullAudioInputStream} The push audio input stream being created.\n   */\n\n\n  static create(callback, format) {\n    return new PullAudioInputStreamImpl(callback, format);\n  }\n\n}\n/**\n * Represents audio input stream used for custom audio input configurations.\n * @private\n * @class PullAudioInputStreamImpl\n */\n\nexport class PullAudioInputStreamImpl extends PullAudioInputStream {\n  /**\n   * Creates a PullAudioInputStream that delegates to the specified callback interface for\n   * read() and close() methods, using the default format (16 kHz 16bit mono PCM).\n   * @constructor\n   * @param {PullAudioInputStreamCallback} callback - The custom audio input object,\n   * derived from PullAudioInputStreamCustomCallback\n   * @param {AudioStreamFormat} format - The audio data format in which audio will be\n   * returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).\n   */\n  constructor(callback, format) {\n    super();\n\n    if (undefined === format) {\n      this.privFormat = AudioStreamFormat.getDefaultInputFormat();\n    } else {\n      this.privFormat = format;\n    }\n\n    this.privEvents = new EventSource();\n    this.privId = createNoDashGuid();\n    this.privCallback = callback;\n    this.privIsClosed = false;\n    this.privBufferSize = this.privFormat.avgBytesPerSec / 10;\n  }\n  /**\n   * Format information for the audio\n   */\n\n\n  get format() {\n    return Promise.resolve(this.privFormat);\n  }\n  /**\n   * Closes the stream.\n   * @member PullAudioInputStreamImpl.prototype.close\n   * @function\n   * @public\n   */\n\n\n  close() {\n    this.privIsClosed = true;\n    this.privCallback.close();\n  }\n\n  id() {\n    return this.privId;\n  }\n\n  get blob() {\n    return Promise.reject(\"Not implemented\");\n  }\n\n  turnOn() {\n    this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\n\n    this.onEvent(new AudioSourceReadyEvent(this.privId));\n    return;\n  }\n\n  attach(audioNodeId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\n      yield this.turnOn();\n      this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\n      return {\n        detach: () => {\n          this.privCallback.close();\n          this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n          return this.turnOff();\n        },\n        id: () => audioNodeId,\n        read: () => {\n          let totalBytes = 0;\n          let transmitBuff; // Until we have the minimum number of bytes to send in a transmission, keep asking for more.\n\n          while (totalBytes < this.privBufferSize) {\n            // Sizing the read buffer to the delta between the perfect size and what's left means we won't ever get too much\n            // data back.\n            const readBuff = new ArrayBuffer(this.privBufferSize - totalBytes);\n            const pulledBytes = this.privCallback.read(readBuff); // If there is no return buffer yet defined, set the return buffer to the that was just populated.\n            // This was, if we have enough data there's no copy penalty, but if we don't we have a buffer that's the\n            // preferred size allocated.\n\n            if (undefined === transmitBuff) {\n              transmitBuff = readBuff;\n            } else {\n              // Not the first bite at the apple, so fill the return buffer with the data we got back.\n              const intView = new Int8Array(transmitBuff);\n              intView.set(new Int8Array(readBuff), totalBytes);\n            } // If there are no bytes to read, just break out and be done.\n\n\n            if (0 === pulledBytes) {\n              break;\n            }\n\n            totalBytes += pulledBytes;\n          }\n\n          return Promise.resolve({\n            buffer: transmitBuff.slice(0, totalBytes),\n            isEnd: this.privIsClosed || totalBytes === 0,\n            timeReceived: Date.now()\n          });\n        }\n      };\n    });\n  }\n\n  detach(audioNodeId) {\n    this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n  }\n\n  turnOff() {\n    return;\n  }\n\n  get events() {\n    return this.privEvents;\n  }\n\n  get deviceInfo() {\n    return Promise.resolve({\n      bitspersample: this.privFormat.bitsPerSample,\n      channelcount: this.privFormat.channels,\n      connectivity: connectivity.Unknown,\n      manufacturer: \"Speech SDK\",\n      model: \"PullStream\",\n      samplerate: this.privFormat.samplesPerSec,\n      type: type.Stream\n    });\n  }\n\n  onEvent(event) {\n    this.privEvents.onEvent(event);\n    Events.instance.onEvent(event);\n  }\n\n} //# sourceMappingURL=AudioInputStream.js.map","map":null,"metadata":{},"sourceType":"module"}