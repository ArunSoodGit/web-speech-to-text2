{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { CognitiveSubscriptionKeyAuthentication, CognitiveTokenAuthentication, Context, OS, ServiceRecognizerBase, SpeechServiceConfig } from \"../common.speech/Exports\";\nimport { Deferred, marshalPromiseToCallbacks } from \"../common/Exports\";\nimport { Contracts } from \"./Contracts\";\nimport { AudioConfig, PropertyId } from \"./Exports\";\n/**\n * Defines the base class Recognizer which mainly contains common event handlers.\n * @class Recognizer\n */\n\nexport class Recognizer {\n  /**\n   * Creates and initializes an instance of a Recognizer\n   * @constructor\n   * @param {AudioConfig} audioInput - An optional audio input stream associated with the recognizer\n   */\n  constructor(audioConfig, properties, connectionFactory) {\n    this.audioConfig = audioConfig !== undefined ? audioConfig : AudioConfig.fromDefaultMicrophoneInput();\n    this.privDisposed = false;\n    this.privProperties = properties.clone();\n    this.privConnectionFactory = connectionFactory;\n    this.implCommonRecognizerSetup();\n  }\n  /**\n   * Dispose of associated resources.\n   * @member Recognizer.prototype.close\n   * @function\n   * @public\n   */\n\n\n  close(cb, errorCb) {\n    Contracts.throwIfDisposed(this.privDisposed);\n    marshalPromiseToCallbacks(this.dispose(true), cb, errorCb);\n  }\n  /**\n   * @Internal\n   * Internal data member to support fromRecognizer* pattern methods on other classes.\n   * Do not use externally, object returned will change without warning or notice.\n   */\n\n\n  get internalData() {\n    return this.privReco;\n  }\n  /**\n   * This method performs cleanup of resources.\n   * The Boolean parameter disposing indicates whether the method is called\n   * from Dispose (if disposing is true) or from the finalizer (if disposing is false).\n   * Derived classes should override this method to dispose resource if needed.\n   * @member Recognizer.prototype.dispose\n   * @function\n   * @public\n   * @param {boolean} disposing - Flag to request disposal.\n   */\n\n\n  dispose(disposing) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.privDisposed) {\n        return;\n      }\n\n      this.privDisposed = true;\n\n      if (disposing) {\n        if (this.privReco) {\n          yield this.privReco.audioSource.turnOff();\n          yield this.privReco.dispose();\n        }\n      }\n    });\n  }\n  /**\n   * This method returns the current state of the telemetry setting.\n   * @member Recognizer.prototype.telemetryEnabled\n   * @function\n   * @public\n   * @returns true if the telemetry is enabled, false otherwise.\n   */\n\n\n  static get telemetryEnabled() {\n    return ServiceRecognizerBase.telemetryDataEnabled;\n  }\n  /**\n   * This method globally enables or disables telemetry.\n   * @member Recognizer.prototype.enableTelemetry\n   * @function\n   * @public\n   * @param enabled - Global setting for telemetry collection.\n   * If set to true, telemetry information like microphone errors,\n   * recognition errors are collected and sent to Microsoft.\n   * If set to false, no telemetry is sent to Microsoft.\n   */\n\n\n  static enableTelemetry(enabled) {\n    ServiceRecognizerBase.telemetryDataEnabled = enabled;\n  } // Does the generic recognizer setup that is common across all recognizer types.\n\n\n  implCommonRecognizerSetup() {\n    let osPlatform = typeof window !== \"undefined\" ? \"Browser\" : \"Node\";\n    let osName = \"unknown\";\n    let osVersion = \"unknown\";\n\n    if (typeof navigator !== \"undefined\") {\n      osPlatform = osPlatform + \"/\" + navigator.platform;\n      osName = navigator.userAgent;\n      osVersion = navigator.appVersion;\n    }\n\n    const recognizerConfig = this.createRecognizerConfig(new SpeechServiceConfig(new Context(new OS(osPlatform, osName, osVersion))));\n    this.privReco = this.createServiceRecognizer(Recognizer.getAuthFromProperties(this.privProperties), this.privConnectionFactory, this.audioConfig, recognizerConfig);\n  }\n\n  recognizeOnceAsyncImpl(recognitionMode) {\n    return __awaiter(this, void 0, void 0, function* () {\n      Contracts.throwIfDisposed(this.privDisposed);\n      const ret = new Deferred();\n      yield this.implRecognizerStop();\n      yield this.privReco.recognize(recognitionMode, ret.resolve, ret.reject);\n      const result = yield ret.promise;\n      yield this.implRecognizerStop();\n      return result;\n    });\n  }\n\n  startContinuousRecognitionAsyncImpl(recognitionMode) {\n    return __awaiter(this, void 0, void 0, function* () {\n      Contracts.throwIfDisposed(this.privDisposed);\n      yield this.implRecognizerStop();\n      yield this.privReco.recognize(recognitionMode, undefined, undefined);\n    });\n  }\n\n  stopContinuousRecognitionAsyncImpl() {\n    return __awaiter(this, void 0, void 0, function* () {\n      Contracts.throwIfDisposed(this.privDisposed);\n      yield this.implRecognizerStop();\n    });\n  }\n\n  implRecognizerStop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.privReco) {\n        yield this.privReco.stopRecognizing();\n      }\n\n      return;\n    });\n  }\n\n  static getAuthFromProperties(properties) {\n    const subscriptionKey = properties.getProperty(PropertyId.SpeechServiceConnection_Key, undefined);\n    const authentication = subscriptionKey && subscriptionKey !== \"\" ? new CognitiveSubscriptionKeyAuthentication(subscriptionKey) : new CognitiveTokenAuthentication(() => {\n      const authorizationToken = properties.getProperty(PropertyId.SpeechServiceAuthorization_Token, undefined);\n      return Promise.resolve(authorizationToken);\n    }, () => {\n      const authorizationToken = properties.getProperty(PropertyId.SpeechServiceAuthorization_Token, undefined);\n      return Promise.resolve(authorizationToken);\n    });\n    return authentication;\n  }\n\n} //# sourceMappingURL=Recognizer.js.map","map":null,"metadata":{},"sourceType":"module"}