{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// Multi-device Conversation is a Preview feature.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/* eslint-disable max-classes-per-file */\n\n\nimport { ConversationConnectionConfig } from \"../../common.speech/Exports\";\nimport { marshalPromiseToCallbacks } from \"../../common/Exports\";\nimport { Contracts } from \"../Contracts\";\nimport { AudioConfig, CancellationErrorCode, CancellationReason, ProfanityOption, PropertyCollection, PropertyId, SpeechTranslationConfig, TranslationRecognizer } from \"../Exports\";\nimport { ConversationImpl } from \"./Conversation\";\nimport { ConversationCommon, ConversationTranslationCanceledEventArgs } from \"./Exports\";\nexport var SpeechState = /*#__PURE__*/(() => {\n  (function (SpeechState) {\n    SpeechState[SpeechState[\"Inactive\"] = 0] = \"Inactive\";\n    SpeechState[SpeechState[\"Connecting\"] = 1] = \"Connecting\";\n    SpeechState[SpeechState[\"Connected\"] = 2] = \"Connected\";\n  })(SpeechState || (SpeechState = {}));\n\n  return SpeechState;\n})();\n\n// child class of TranslationRecognizer meant only for use with ConversationTranslator\nclass ConversationTranslationRecognizer extends TranslationRecognizer {\n  constructor(speechConfig, audioConfig, translator) {\n    super(speechConfig, audioConfig);\n    this.privSpeechState = SpeechState.Inactive;\n\n    if (!!translator) {\n      this.privTranslator = translator;\n\n      this.sessionStarted = () => {\n        this.privSpeechState = SpeechState.Connected;\n      };\n\n      this.sessionStopped = () => {\n        this.privSpeechState = SpeechState.Inactive;\n      }; // eslint-disable-next-line @typescript-eslint/no-misused-promises\n\n\n      this.recognized = (tr, e) => __awaiter(this, void 0, void 0, function* () {\n        // TODO: add support for getting recognitions from here if own speech\n        var _a; // if there is an error connecting to the conversation service from the speech service the error will be returned in the ErrorDetails field.\n\n\n        if ((_a = e.result) === null || _a === void 0 ? void 0 : _a.errorDetails) {\n          yield this.cancelSpeech(); // TODO: format the error message contained in 'errorDetails'\n\n          this.fireCancelEvent(e.result.errorDetails);\n        }\n      }); // eslint-disable-next-line @typescript-eslint/no-misused-promises\n\n\n      this.canceled = () => __awaiter(this, void 0, void 0, function* () {\n        if (this.privSpeechState !== SpeechState.Inactive) {\n          try {\n            yield this.cancelSpeech();\n          } catch (error) {\n            this.privSpeechState = SpeechState.Inactive;\n          }\n        }\n      });\n    }\n  }\n\n  get state() {\n    return this.privSpeechState;\n  }\n\n  set state(newState) {\n    this.privSpeechState = newState;\n  }\n\n  onConnection() {\n    this.privSpeechState = SpeechState.Connected;\n  }\n\n  onDisconnection() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privSpeechState = SpeechState.Inactive;\n      yield this.cancelSpeech();\n    });\n  }\n  /**\n   * Fire a cancel event\n   * @param error\n   */\n\n\n  fireCancelEvent(error) {\n    try {\n      if (!!this.privTranslator.canceled) {\n        const cancelEvent = new ConversationTranslationCanceledEventArgs(CancellationReason.Error, error, CancellationErrorCode.RuntimeError);\n        this.privTranslator.canceled(this.privTranslator, cancelEvent);\n      }\n    } catch (e) {//\n    }\n  }\n\n  cancelSpeech() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this.stopContinuousRecognitionAsync();\n        yield (_a = this.privReco) === null || _a === void 0 ? void 0 : _a.disconnect();\n        this.privSpeechState = SpeechState.Inactive;\n      } catch (e) {// ignore the error\n      }\n    });\n  }\n\n}\n/**\n * Join, leave or connect to a conversation.\n */\n\n\nexport class ConversationTranslator extends ConversationCommon {\n  constructor(audioConfig) {\n    super(audioConfig);\n    this.privErrors = ConversationConnectionConfig.restErrors;\n    this.privIsDisposed = false;\n    this.privIsSpeaking = false;\n    this.privPlaceholderKey = \"abcdefghijklmnopqrstuvwxyz012345\";\n    this.privPlaceholderRegion = \"westus\";\n    this.privProperties = new PropertyCollection();\n  }\n\n  get properties() {\n    return this.privProperties;\n  }\n\n  get speechRecognitionLanguage() {\n    return this.privSpeechRecognitionLanguage;\n  }\n\n  get participants() {\n    var _a;\n\n    return (_a = this.privConversation) === null || _a === void 0 ? void 0 : _a.participants;\n  }\n\n  get canSpeak() {\n    // is there a Conversation websocket available and has the Recognizer been set up\n    if (!this.privConversation.isConnected || !this.privCTRecognizer) {\n      return false;\n    } // is the user already speaking\n\n\n    if (this.privIsSpeaking || this.privCTRecognizer.state === SpeechState.Connected || this.privCTRecognizer.state === SpeechState.Connecting) {\n      return false;\n    } // is the user muted\n\n\n    if (this.privConversation.isMutedByHost) {\n      return false;\n    }\n\n    return true;\n  }\n\n  joinConversationAsync(conversation, nickname, param1, param2, param3) {\n    try {\n      if (typeof conversation === \"string\") {\n        Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversation id\"));\n        Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\n\n        if (!!this.privConversation) {\n          this.handleError(new Error(this.privErrors.permissionDeniedStart), param3);\n        }\n\n        let lang = param1;\n\n        if (lang === undefined || lang === null || lang === \"\") {\n          lang = ConversationConnectionConfig.defaultLanguageCode;\n        } // create a placeholder config\n\n\n        this.privSpeechTranslationConfig = SpeechTranslationConfig.fromSubscription(this.privPlaceholderKey, this.privPlaceholderRegion);\n        this.privSpeechTranslationConfig.setProfanity(ProfanityOption.Masked);\n        this.privSpeechTranslationConfig.addTargetLanguage(lang);\n        this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage], lang);\n        this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.ConversationTranslator_Name], nickname);\n        const endpoint = this.privProperties.getProperty(PropertyId.ConversationTranslator_Host);\n\n        if (endpoint) {\n          this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.ConversationTranslator_Host], endpoint);\n        }\n\n        const speechEndpointHost = this.privProperties.getProperty(PropertyId.SpeechServiceConnection_Host);\n\n        if (speechEndpointHost) {\n          this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_Host], speechEndpointHost);\n        } // join the conversation\n\n\n        this.privConversation = new ConversationImpl(this.privSpeechTranslationConfig);\n        this.privConversation.conversationTranslator = this;\n        this.privConversation.joinConversationAsync(conversation, nickname, lang, result => {\n          if (!result) {\n            this.handleError(new Error(this.privErrors.permissionDeniedConnect), param3);\n          }\n\n          this.privSpeechTranslationConfig.authorizationToken = result; // connect to the ws\n\n          this.privConversation.startConversationAsync(() => {\n            this.handleCallback(param2, param3);\n          }, error => {\n            this.handleError(error, param3);\n          });\n        }, error => {\n          this.handleError(error, param3);\n        });\n      } else if (typeof conversation === \"object\") {\n        Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversation id\"));\n        Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\")); // save the nickname\n\n        this.privProperties.setProperty(PropertyId.ConversationTranslator_Name, nickname); // ref the conversation object\n\n        this.privConversation = conversation; // ref the conversation translator object\n\n        this.privConversation.conversationTranslator = this;\n        Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedConnect);\n        Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);\n        this.privSpeechTranslationConfig = conversation.config;\n        this.handleCallback(param1, param2);\n      } else {\n        this.handleError(new Error(this.privErrors.invalidArgs.replace(\"{arg}\", \"invalid conversation type\")), param2);\n      }\n    } catch (error) {\n      this.handleError(error, typeof param1 === \"string\" ? param3 : param2);\n    }\n  }\n  /**\n   * Leave the conversation\n   * @param cb\n   * @param err\n   */\n\n\n  leaveConversationAsync(cb, err) {\n    marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n      // stop the speech websocket\n      yield this.cancelSpeech(); // stop the websocket\n\n      yield this.privConversation.endConversationImplAsync(); // https delete request\n\n      yield this.privConversation.deleteConversationImplAsync();\n      this.dispose();\n    }))(), cb, err);\n  }\n  /**\n   * Send a text message\n   * @param message\n   * @param cb\n   * @param err\n   */\n\n\n  sendTextMessageAsync(message, cb, err) {\n    try {\n      Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);\n      Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace(\"{arg}\", message));\n      this.privConversation.sendTextMessageAsync(message, cb, err);\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Start speaking\n   * @param cb\n   * @param err\n   */\n\n\n  startTranscribingAsync(cb, err) {\n    marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n      try {\n        Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);\n        Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);\n\n        if (this.privCTRecognizer === undefined) {\n          yield this.connectTranslatorRecognizer();\n        }\n\n        Contracts.throwIfNullOrUndefined(this.privCTRecognizer, this.privErrors.permissionDeniedSend);\n\n        if (!this.canSpeak) {\n          this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n        }\n\n        yield this.startContinuousRecognition();\n        this.privIsSpeaking = true;\n      } catch (error) {\n        this.privIsSpeaking = false;\n        yield this.cancelSpeech();\n        throw error;\n      }\n    }))(), cb, err);\n  }\n  /**\n   * Stop speaking\n   * @param cb\n   * @param err\n   */\n\n\n  stopTranscribingAsync(cb, err) {\n    marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!this.privIsSpeaking) {\n          // stop speech\n          yield this.cancelSpeech();\n          return;\n        } // stop the recognition but leave the websocket open\n\n\n        this.privIsSpeaking = false;\n        yield new Promise((resolve, reject) => {\n          this.privCTRecognizer.stopContinuousRecognitionAsync(resolve, reject);\n        });\n      } catch (error) {\n        yield this.cancelSpeech();\n      }\n    }))(), cb, err);\n  }\n\n  isDisposed() {\n    return this.privIsDisposed;\n  }\n\n  dispose(reason, success, err) {\n    marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n      if (this.isDisposed && !this.privIsSpeaking) {\n        return;\n      }\n\n      yield this.cancelSpeech();\n      this.privIsDisposed = true;\n      this.privSpeechTranslationConfig.close();\n      this.privSpeechRecognitionLanguage = undefined;\n      this.privProperties = undefined;\n      this.privAudioConfig = undefined;\n      this.privSpeechTranslationConfig = undefined;\n      this.privConversation.dispose();\n      this.privConversation = undefined;\n    }))(), success, err);\n  }\n  /**\n   * Cancel the speech websocket\n   */\n\n\n  cancelSpeech() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this.privIsSpeaking = false;\n        yield (_a = this.privCTRecognizer) === null || _a === void 0 ? void 0 : _a.onDisconnection();\n        this.privCTRecognizer = undefined;\n      } catch (e) {// ignore the error\n      }\n    });\n  }\n  /**\n   * Connect to the speech translation recognizer.\n   * Currently there is no language validation performed before sending the SpeechLanguage code to the service.\n   * If it's an invalid language the raw error will be: 'Error during WebSocket handshake: Unexpected response code: 400'\n   * e.g. pass in 'fr' instead of 'fr-FR', or a text-only language 'cy'\n   */\n\n\n  connectTranslatorRecognizer() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (this.privAudioConfig === undefined) {\n          this.privAudioConfig = AudioConfig.fromDefaultMicrophoneInput();\n        } // clear the temp subscription key if it's a participant joining\n\n\n        if (this.privSpeechTranslationConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_Key]) === this.privPlaceholderKey) {\n          this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_Key], \"\");\n        } // TODO\n\n\n        const token = encodeURIComponent(this.privConversation.room.token);\n        let endpointHost = this.privSpeechTranslationConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_Host], ConversationConnectionConfig.speechHost);\n        endpointHost = endpointHost.replace(\"{region}\", this.privConversation.room.cognitiveSpeechRegion);\n        const url = `wss://${endpointHost}${ConversationConnectionConfig.speechPath}?${ConversationConnectionConfig.configParams.token}=${token}`;\n        this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_Endpoint], url);\n        this.privCTRecognizer = new ConversationTranslationRecognizer(this.privSpeechTranslationConfig, this.privAudioConfig, this);\n      } catch (error) {\n        yield this.cancelSpeech();\n        throw error;\n      }\n    });\n  }\n  /**\n   * Handle the start speaking request\n   */\n\n\n  startContinuousRecognition() {\n    return new Promise((resolve, reject) => {\n      this.privCTRecognizer.startContinuousRecognitionAsync(resolve, reject);\n    });\n  }\n\n} //# sourceMappingURL=ConversationTranslator.js.map","map":null,"metadata":{},"sourceType":"module"}