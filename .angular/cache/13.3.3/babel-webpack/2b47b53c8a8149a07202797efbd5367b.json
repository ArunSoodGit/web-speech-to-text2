{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { RecognitionMode, RecognizerConfig, TranslationConnectionFactory, TranslationServiceRecognizer } from \"../common.speech/Exports\";\nimport { marshalPromiseToCallbacks } from \"../common/Exports\";\nimport { Connection } from \"./Connection\";\nimport { Contracts } from \"./Contracts\";\nimport { PropertyId, Recognizer } from \"./Exports\";\n/**\n * Translation recognizer\n * @class TranslationRecognizer\n */\n\nexport class TranslationRecognizer extends Recognizer {\n  /**\n   * Initializes an instance of the TranslationRecognizer.\n   * @constructor\n   * @param {SpeechTranslationConfig} speechConfig - Set of properties to configure this recognizer.\n   * @param {AudioConfig} audioConfig - An optional audio config associated with the recognizer\n   */\n  constructor(speechConfig, audioConfig) {\n    const configImpl = speechConfig;\n    Contracts.throwIfNull(configImpl, \"speechConfig\");\n    super(audioConfig, configImpl.properties, new TranslationConnectionFactory());\n    this.privDisposedTranslationRecognizer = false;\n\n    if (this.properties.getProperty(PropertyId.SpeechServiceConnection_TranslationVoice, undefined) !== undefined) {\n      Contracts.throwIfNullOrWhitespace(this.properties.getProperty(PropertyId.SpeechServiceConnection_TranslationVoice), PropertyId[PropertyId.SpeechServiceConnection_TranslationVoice]);\n    }\n\n    Contracts.throwIfNullOrWhitespace(this.properties.getProperty(PropertyId.SpeechServiceConnection_TranslationToLanguages), PropertyId[PropertyId.SpeechServiceConnection_TranslationToLanguages]);\n    Contracts.throwIfNullOrWhitespace(this.properties.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage), PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage]);\n  }\n  /**\n   * Gets the language name that was set when the recognizer was created.\n   * @member TranslationRecognizer.prototype.speechRecognitionLanguage\n   * @function\n   * @public\n   * @returns {string} Gets the language name that was set when the recognizer was created.\n   */\n\n\n  get speechRecognitionLanguage() {\n    Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);\n    return this.properties.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage);\n  }\n  /**\n   * Gets target languages for translation that were set when the recognizer was created.\n   * The language is specified in BCP-47 format. The translation will provide translated text for each of language.\n   * @member TranslationRecognizer.prototype.targetLanguages\n   * @function\n   * @public\n   * @returns {string[]} Gets target languages for translation that were set when the recognizer was created.\n   */\n\n\n  get targetLanguages() {\n    Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);\n    return this.properties.getProperty(PropertyId.SpeechServiceConnection_TranslationToLanguages).split(\",\");\n  }\n  /**\n   * Gets the name of output voice.\n   * @member TranslationRecognizer.prototype.voiceName\n   * @function\n   * @public\n   * @returns {string} the name of output voice.\n   */\n\n\n  get voiceName() {\n    Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);\n    return this.properties.getProperty(PropertyId.SpeechServiceConnection_TranslationVoice, undefined);\n  }\n  /**\n   * The collection of properties and their values defined for this TranslationRecognizer.\n   * @member TranslationRecognizer.prototype.properties\n   * @function\n   * @public\n   * @returns {PropertyCollection} The collection of properties and their values defined for this TranslationRecognizer.\n   */\n\n\n  get properties() {\n    return this.privProperties;\n  }\n  /**\n   * Gets the authorization token used to communicate with the service.\n   * @member TranslationRecognizer.prototype.authorizationToken\n   * @function\n   * @public\n   * @returns {string} Authorization token.\n   */\n\n\n  get authorizationToken() {\n    return this.properties.getProperty(PropertyId.SpeechServiceAuthorization_Token);\n  }\n  /**\n   * Gets/Sets the authorization token used to communicate with the service.\n   * @member TranslationRecognizer.prototype.authorizationToken\n   * @function\n   * @public\n   * @param {string} value - Authorization token.\n   */\n\n\n  set authorizationToken(value) {\n    this.properties.setProperty(PropertyId.SpeechServiceAuthorization_Token, value);\n  }\n  /**\n   * Starts recognition and translation, and stops after the first utterance is recognized.\n   * The task returns the translation text as result.\n   * Note: recognizeOnceAsync returns when the first utterance has been recognized, so it is suitable only\n   * for single shot recognition like command or query. For long-running recognition,\n   * use startContinuousRecognitionAsync() instead.\n   * @member TranslationRecognizer.prototype.recognizeOnceAsync\n   * @function\n   * @public\n   * @param cb - Callback that received the result when the translation has completed.\n   * @param err - Callback invoked in case of an error.\n   */\n\n\n  recognizeOnceAsync(cb, err) {\n    Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);\n    marshalPromiseToCallbacks(this.recognizeOnceAsyncImpl(RecognitionMode.Conversation), cb, err);\n  }\n  /**\n   * Starts recognition and translation, until stopContinuousRecognitionAsync() is called.\n   * User must subscribe to events to receive translation results.\n   * @member TranslationRecognizer.prototype.startContinuousRecognitionAsync\n   * @function\n   * @public\n   * @param cb - Callback that received the translation has started.\n   * @param err - Callback invoked in case of an error.\n   */\n\n\n  startContinuousRecognitionAsync(cb, err) {\n    marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(RecognitionMode.Conversation), cb, err);\n  }\n  /**\n   * Stops continuous recognition and translation.\n   * @member TranslationRecognizer.prototype.stopContinuousRecognitionAsync\n   * @function\n   * @public\n   * @param cb - Callback that received the translation has stopped.\n   * @param err - Callback invoked in case of an error.\n   */\n\n\n  stopContinuousRecognitionAsync(cb, err) {\n    marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), cb, err);\n  }\n  /**\n   * dynamically remove a language from list of target language\n   * (can be used while recognition is ongoing)\n   * @member TranslationRecognizer.prototype.removeTargetLanguage\n   * @function\n   * @param lang - language to be removed\n   * @public\n   */\n\n\n  removeTargetLanguage(lang) {\n    Contracts.throwIfNullOrUndefined(lang, \"language to be removed\");\n\n    if (this.properties.getProperty(PropertyId.SpeechServiceConnection_TranslationToLanguages, undefined) !== undefined) {\n      const languages = this.properties.getProperty(PropertyId.SpeechServiceConnection_TranslationToLanguages).split(\",\");\n      const index = languages.indexOf(lang);\n\n      if (index > -1) {\n        languages.splice(index, 1);\n        this.properties.setProperty(PropertyId.SpeechServiceConnection_TranslationToLanguages, languages.join(\",\"));\n        this.updateLanguages(languages);\n      }\n    }\n  }\n  /**\n   * dynamically add a language to list of target language\n   * (can be used while recognition is ongoing)\n   * @member TranslationRecognizer.prototype.addTargetLanguage\n   * @function\n   * @param lang - language to be added\n   * @public\n   */\n\n\n  addTargetLanguage(lang) {\n    Contracts.throwIfNullOrUndefined(lang, \"language to be added\");\n    let languages = [];\n\n    if (this.properties.getProperty(PropertyId.SpeechServiceConnection_TranslationToLanguages, undefined) !== undefined) {\n      languages = this.properties.getProperty(PropertyId.SpeechServiceConnection_TranslationToLanguages).split(\",\");\n\n      if (!languages.includes(lang)) {\n        languages.push(lang);\n        this.properties.setProperty(PropertyId.SpeechServiceConnection_TranslationToLanguages, languages.join(\",\"));\n      }\n    } else {\n      this.properties.setProperty(PropertyId.SpeechServiceConnection_TranslationToLanguages, lang);\n      languages = [lang];\n    }\n\n    this.updateLanguages(languages);\n  }\n  /**\n   * closes all external resources held by an instance of this class.\n   * @member TranslationRecognizer.prototype.close\n   * @function\n   * @public\n   */\n\n\n  close(cb, errorCb) {\n    Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);\n    marshalPromiseToCallbacks(this.dispose(true), cb, errorCb);\n  }\n  /**\n   * handles ConnectionEstablishedEvent for conversation translation scenarios.\n   * @member TranslationRecognizer.prototype.onConnection\n   * @function\n   * @public\n   */\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\n  onConnection() {}\n  /**\n   * handles disconnection events for conversation translation scenarios.\n   * @member TranslationRecognizer.prototype.onDisconnection\n   * @function\n   * @public\n   */\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\n  onDisconnection() {\n    return __awaiter(this, void 0, void 0, function* () {});\n  }\n\n  dispose(disposing) {\n    const _super = Object.create(null, {\n      dispose: {\n        get: () => super.dispose\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.privDisposedTranslationRecognizer) {\n        return;\n      }\n\n      this.privDisposedTranslationRecognizer = true;\n\n      if (disposing) {\n        yield this.implRecognizerStop();\n        yield _super.dispose.call(this, disposing);\n      }\n    });\n  }\n\n  createRecognizerConfig(speechConfig) {\n    return new RecognizerConfig(speechConfig, this.properties);\n  }\n\n  createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {\n    const configImpl = audioConfig;\n    return new TranslationServiceRecognizer(authentication, connectionFactory, configImpl, recognizerConfig, this);\n  }\n\n  updateLanguages(languages) {\n    const conn = Connection.fromRecognizer(this);\n\n    if (!!conn) {\n      conn.setMessageProperty(\"speech.context\", \"translationcontext\", {\n        to: languages\n      });\n      conn.sendMessageAsync(\"event\", JSON.stringify({\n        id: \"translation\",\n        name: \"updateLanguage\",\n        to: languages\n      }));\n    }\n  }\n\n} //# sourceMappingURL=TranslationRecognizer.js.map","map":null,"metadata":{},"sourceType":"module"}