{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ArgumentNullError, ConnectionState, createNoDashGuid, EventSource, MessageType, ServiceEvent } from \"../common/Exports\";\nimport { CancellationErrorCode, CancellationReason, PropertyCollection, PropertyId, ResultReason, SpeechSynthesisBookmarkEventArgs, SpeechSynthesisEventArgs, SpeechSynthesisResult, SpeechSynthesisVisemeEventArgs, SpeechSynthesisWordBoundaryEventArgs } from \"../sdk/Exports\";\nimport { AgentConfig, CancellationErrorCodePropertyName, MetadataType, SynthesisAudioMetadata, SynthesisContext, SynthesisTurn } from \"./Exports\";\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\nexport let SynthesisAdapterBase = /*#__PURE__*/(() => {\n  class SynthesisAdapterBase {\n    constructor(authentication, connectionFactory, synthesizerConfig, speechSynthesizer, audioDestination) {\n      this.speakOverride = undefined;\n      this.receiveMessageOverride = undefined;\n      this.connectImplOverride = undefined;\n      this.configConnectionOverride = undefined; // A promise for a configured connection.\n      // Do not consume directly, call fetchConnection instead.\n\n      this.privConnectionConfigurationPromise = undefined;\n\n      if (!authentication) {\n        throw new ArgumentNullError(\"authentication\");\n      }\n\n      if (!connectionFactory) {\n        throw new ArgumentNullError(\"connectionFactory\");\n      }\n\n      if (!synthesizerConfig) {\n        throw new ArgumentNullError(\"synthesizerConfig\");\n      }\n\n      this.privAuthentication = authentication;\n      this.privConnectionFactory = connectionFactory;\n      this.privSynthesizerConfig = synthesizerConfig;\n      this.privIsDisposed = false;\n      this.privSpeechSynthesizer = speechSynthesizer;\n      this.privSessionAudioDestination = audioDestination;\n      this.privSynthesisTurn = new SynthesisTurn();\n      this.privConnectionEvents = new EventSource();\n      this.privServiceEvents = new EventSource();\n      this.privSynthesisContext = new SynthesisContext(this.privSpeechSynthesizer);\n      this.privAgentConfig = new AgentConfig();\n      this.connectionEvents.attach(connectionEvent => {\n        if (connectionEvent.name === \"ConnectionClosedEvent\") {\n          const connectionClosedEvent = connectionEvent;\n\n          if (connectionClosedEvent.statusCode !== 1000) {\n            this.cancelSynthesisLocal(CancellationReason.Error, connectionClosedEvent.statusCode === 1007 ? CancellationErrorCode.BadRequestParameters : CancellationErrorCode.ConnectionFailure, `${connectionClosedEvent.reason} websocket error code: ${connectionClosedEvent.statusCode}`);\n          }\n        }\n      });\n    }\n\n    get synthesisContext() {\n      return this.privSynthesisContext;\n    }\n\n    get agentConfig() {\n      return this.privAgentConfig;\n    }\n\n    get connectionEvents() {\n      return this.privConnectionEvents;\n    }\n\n    get serviceEvents() {\n      return this.privServiceEvents;\n    }\n\n    set activityTemplate(messagePayload) {\n      this.privActivityTemplate = messagePayload;\n    }\n\n    get activityTemplate() {\n      return this.privActivityTemplate;\n    }\n\n    set audioOutputFormat(format) {\n      this.privAudioOutputFormat = format;\n      this.privSynthesisTurn.audioOutputFormat = format;\n\n      if (this.privSessionAudioDestination !== undefined) {\n        this.privSessionAudioDestination.format = format;\n      }\n\n      if (this.synthesisContext !== undefined) {\n        this.synthesisContext.audioOutputFormat = format;\n      }\n    }\n\n    static addHeader(audio, format) {\n      if (!format.hasHeader) {\n        return audio;\n      }\n\n      format.updateHeader(audio.byteLength);\n      const tmp = new Uint8Array(audio.byteLength + format.header.byteLength);\n      tmp.set(new Uint8Array(format.header), 0);\n      tmp.set(new Uint8Array(audio), format.header.byteLength);\n      return tmp.buffer;\n    }\n\n    isDisposed() {\n      return this.privIsDisposed;\n    }\n\n    dispose(reason) {\n      return __awaiter(this, void 0, void 0, function* () {\n        this.privIsDisposed = true;\n\n        if (this.privSessionAudioDestination !== undefined) {\n          this.privSessionAudioDestination.close();\n        }\n\n        if (this.privConnectionConfigurationPromise !== undefined) {\n          const connection = yield this.privConnectionConfigurationPromise;\n          yield connection.dispose(reason);\n        }\n      });\n    }\n\n    connect() {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield this.connectImpl();\n      });\n    }\n\n    sendNetworkMessage(path, payload) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const type = typeof payload === \"string\" ? MessageType.Text : MessageType.Binary;\n        const contentType = typeof payload === \"string\" ? \"application/json\" : \"\";\n        const connection = yield this.fetchConnection();\n        return connection.send(new SpeechConnectionMessage(type, path, this.privSynthesisTurn.requestId, contentType, payload));\n      });\n    }\n\n    Speak(text, isSSML, requestId, successCallback, errorCallBack, audioDestination) {\n      return __awaiter(this, void 0, void 0, function* () {\n        let ssml;\n\n        if (isSSML) {\n          ssml = text;\n        } else {\n          ssml = this.privSpeechSynthesizer.buildSsml(text);\n        }\n\n        if (this.speakOverride !== undefined) {\n          return this.speakOverride(ssml, requestId, successCallback, errorCallBack);\n        }\n\n        this.privSuccessCallback = successCallback;\n        this.privErrorCallback = errorCallBack;\n        this.privSynthesisTurn.startNewSynthesis(requestId, text, isSSML, audioDestination);\n\n        try {\n          yield this.connectImpl();\n          const connection = yield this.fetchConnection();\n          yield this.sendSynthesisContext(connection);\n          yield this.sendSsmlMessage(connection, ssml, requestId);\n          const synthesisStartEventArgs = new SpeechSynthesisEventArgs(new SpeechSynthesisResult(requestId, ResultReason.SynthesizingAudioStarted));\n\n          if (!!this.privSpeechSynthesizer.synthesisStarted) {\n            this.privSpeechSynthesizer.synthesisStarted(this.privSpeechSynthesizer, synthesisStartEventArgs);\n          }\n\n          void this.receiveMessage();\n        } catch (e) {\n          this.cancelSynthesisLocal(CancellationReason.Error, CancellationErrorCode.ConnectionFailure, e);\n          return Promise.reject(e);\n        }\n      });\n    } // Cancels synthesis.\n\n\n    cancelSynthesis(requestId, cancellationReason, errorCode, error) {\n      const properties = new PropertyCollection();\n      properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\n      const result = new SpeechSynthesisResult(requestId, ResultReason.Canceled, undefined, error, properties);\n\n      if (!!this.privSpeechSynthesizer.SynthesisCanceled) {\n        const cancelEvent = new SpeechSynthesisEventArgs(result);\n\n        try {\n          this.privSpeechSynthesizer.SynthesisCanceled(this.privSpeechSynthesizer, cancelEvent);\n          /* eslint-disable no-empty */\n        } catch (_a) {}\n      }\n\n      if (!!this.privSuccessCallback) {\n        try {\n          this.privSuccessCallback(result);\n          /* eslint-disable no-empty */\n        } catch (_b) {}\n      }\n    } // Cancels synthesis.\n\n\n    cancelSynthesisLocal(cancellationReason, errorCode, error) {\n      if (!!this.privSynthesisTurn.isSynthesizing) {\n        this.privSynthesisTurn.onStopSynthesizing();\n        this.cancelSynthesis(this.privSynthesisTurn.requestId, cancellationReason, errorCode, error);\n      }\n    } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    processTypeSpecificMessages(connectionMessage) {\n      return true;\n    }\n\n    receiveMessage() {\n      return __awaiter(this, void 0, void 0, function* () {\n        try {\n          const connection = yield this.fetchConnection();\n          const message = yield connection.read();\n\n          if (this.receiveMessageOverride !== undefined) {\n            return this.receiveMessageOverride();\n          }\n\n          if (this.privIsDisposed) {\n            // We're done.\n            return;\n          } // indicates we are draining the queue and it came with no message;\n\n\n          if (!message) {\n            if (!this.privSynthesisTurn.isSynthesizing) {\n              return;\n            } else {\n              return this.receiveMessage();\n            }\n          }\n\n          const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\n\n          if (connectionMessage.requestId.toLowerCase() === this.privSynthesisTurn.requestId.toLowerCase()) {\n            switch (connectionMessage.path.toLowerCase()) {\n              case \"turn.start\":\n                this.privSynthesisTurn.onServiceTurnStartResponse();\n                break;\n\n              case \"response\":\n                this.privSynthesisTurn.onServiceResponseMessage(connectionMessage.textBody);\n                break;\n\n              case \"audio\":\n                if (this.privSynthesisTurn.streamId.toLowerCase() === connectionMessage.streamId.toLowerCase() && !!connectionMessage.binaryBody) {\n                  this.privSynthesisTurn.onAudioChunkReceived(connectionMessage.binaryBody);\n\n                  if (!!this.privSpeechSynthesizer.synthesizing) {\n                    try {\n                      const audioWithHeader = SynthesisAdapterBase.addHeader(connectionMessage.binaryBody, this.privSynthesisTurn.audioOutputFormat);\n                      const ev = new SpeechSynthesisEventArgs(new SpeechSynthesisResult(this.privSynthesisTurn.requestId, ResultReason.SynthesizingAudio, audioWithHeader));\n                      this.privSpeechSynthesizer.synthesizing(this.privSpeechSynthesizer, ev);\n                    } catch (error) {// Not going to let errors in the event handler\n                      // trip things up.\n                    }\n                  }\n\n                  if (this.privSessionAudioDestination !== undefined) {\n                    this.privSessionAudioDestination.write(connectionMessage.binaryBody);\n                  }\n                }\n\n                break;\n\n              case \"audio.metadata\":\n                const metadataList = SynthesisAudioMetadata.fromJSON(connectionMessage.textBody).Metadata;\n\n                for (const metadata of metadataList) {\n                  switch (metadata.Type) {\n                    case MetadataType.WordBoundary:\n                    case MetadataType.SentenceBoundary:\n                      this.privSynthesisTurn.onTextBoundaryEvent(metadata);\n                      const wordBoundaryEventArgs = new SpeechSynthesisWordBoundaryEventArgs(metadata.Data.Offset, metadata.Data.Duration, metadata.Data.text.Text, metadata.Data.text.Length, metadata.Type === MetadataType.WordBoundary ? this.privSynthesisTurn.currentTextOffset : this.privSynthesisTurn.currentSentenceOffset, metadata.Data.text.BoundaryType);\n\n                      if (!!this.privSpeechSynthesizer.wordBoundary) {\n                        try {\n                          this.privSpeechSynthesizer.wordBoundary(this.privSpeechSynthesizer, wordBoundaryEventArgs);\n                        } catch (error) {// Not going to let errors in the event handler\n                          // trip things up.\n                        }\n                      }\n\n                      break;\n\n                    case MetadataType.Bookmark:\n                      const bookmarkEventArgs = new SpeechSynthesisBookmarkEventArgs(metadata.Data.Offset, metadata.Data.Bookmark);\n\n                      if (!!this.privSpeechSynthesizer.bookmarkReached) {\n                        try {\n                          this.privSpeechSynthesizer.bookmarkReached(this.privSpeechSynthesizer, bookmarkEventArgs);\n                        } catch (error) {// Not going to let errors in the event handler\n                          // trip things up.\n                        }\n                      }\n\n                      break;\n\n                    case MetadataType.Viseme:\n                      this.privSynthesisTurn.onVisemeMetadataReceived(metadata);\n\n                      if (metadata.Data.IsLastAnimation) {\n                        const visemeEventArgs = new SpeechSynthesisVisemeEventArgs(metadata.Data.Offset, metadata.Data.VisemeId, this.privSynthesisTurn.getAndClearVisemeAnimation());\n\n                        if (!!this.privSpeechSynthesizer.visemeReceived) {\n                          try {\n                            this.privSpeechSynthesizer.visemeReceived(this.privSpeechSynthesizer, visemeEventArgs);\n                          } catch (error) {// Not going to let errors in the event handler\n                            // trip things up.\n                          }\n                        }\n                      }\n\n                      break;\n\n                    case MetadataType.SessionEnd:\n                      this.privSynthesisTurn.onSessionEnd(metadata);\n                      break;\n                  }\n                }\n\n                break;\n\n              case \"turn.end\":\n                this.privSynthesisTurn.onServiceTurnEndResponse();\n                let result;\n\n                try {\n                  const audioBuffer = yield this.privSynthesisTurn.getAllReceivedAudioWithHeader();\n                  result = new SpeechSynthesisResult(this.privSynthesisTurn.requestId, ResultReason.SynthesizingAudioCompleted, audioBuffer, undefined, undefined, this.privSynthesisTurn.audioDuration);\n\n                  if (!!this.privSuccessCallback) {\n                    this.privSuccessCallback(result);\n                  }\n                } catch (error) {\n                  if (!!this.privErrorCallback) {\n                    this.privErrorCallback(error);\n                  }\n                }\n\n                if (this.privSpeechSynthesizer.synthesisCompleted) {\n                  try {\n                    this.privSpeechSynthesizer.synthesisCompleted(this.privSpeechSynthesizer, new SpeechSynthesisEventArgs(result));\n                  } catch (e) {// Not going to let errors in the event handler\n                    // trip things up.\n                  }\n                }\n\n                break;\n\n              default:\n                if (!this.processTypeSpecificMessages(connectionMessage)) {\n                  // here are some messages that the derived class has not processed, dispatch them to connect class\n                  if (!!this.privServiceEvents) {\n                    this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\n                  }\n                }\n\n            }\n          }\n\n          return this.receiveMessage();\n        } catch (e) {// TODO: What goes here?\n        }\n      });\n    }\n\n    sendSynthesisContext(connection) {\n      const synthesisContextJson = this.synthesisContext.toJSON();\n\n      if (synthesisContextJson) {\n        return connection.send(new SpeechConnectionMessage(MessageType.Text, \"synthesis.context\", this.privSynthesisTurn.requestId, \"application/json\", synthesisContextJson));\n      }\n\n      return;\n    }\n\n    connectImpl(isUnAuthorized = false) {\n      if (this.privConnectionPromise != null) {\n        return this.privConnectionPromise.then(connection => {\n          if (connection.state() === ConnectionState.Disconnected) {\n            this.privConnectionId = null;\n            this.privConnectionPromise = null;\n            return this.connectImpl();\n          }\n\n          return this.privConnectionPromise;\n        }, () => {\n          this.privConnectionId = null;\n          this.privConnectionPromise = null;\n          return this.connectImpl();\n        });\n      }\n\n      this.privAuthFetchEventId = createNoDashGuid();\n      this.privConnectionId = createNoDashGuid();\n      this.privSynthesisTurn.onPreConnectionStart(this.privAuthFetchEventId);\n      const authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);\n      this.privConnectionPromise = authPromise.then(result => __awaiter(this, void 0, void 0, function* () {\n        this.privSynthesisTurn.onAuthCompleted(false);\n        const connection = this.privConnectionFactory.create(this.privSynthesizerConfig, result, this.privConnectionId); // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\n        // it'll stop sending events.\n\n        connection.events.attach(event => {\n          this.connectionEvents.onEvent(event);\n        });\n        const response = yield connection.open();\n\n        if (response.statusCode === 200) {\n          this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);\n          return Promise.resolve(connection);\n        } else if (response.statusCode === 403 && !isUnAuthorized) {\n          return this.connectImpl(true);\n        } else {\n          this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);\n          return Promise.reject(`Unable to contact server. StatusCode: ${response.statusCode}, ${this.privSynthesizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${response.reason}`);\n        }\n      }), error => {\n        this.privSynthesisTurn.onAuthCompleted(true);\n        throw new Error(error);\n      }); // Attach an empty handler to allow the promise to run in the background while\n      // other startup events happen. It'll eventually be awaited on.\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n      this.privConnectionPromise.catch(() => {});\n      return this.privConnectionPromise;\n    }\n\n    sendSpeechServiceConfig(connection, SpeechServiceConfigJson) {\n      if (SpeechServiceConfigJson) {\n        return connection.send(new SpeechConnectionMessage(MessageType.Text, \"speech.config\", this.privSynthesisTurn.requestId, \"application/json\", SpeechServiceConfigJson));\n      }\n    }\n\n    sendSsmlMessage(connection, ssml, requestId) {\n      return connection.send(new SpeechConnectionMessage(MessageType.Text, \"ssml\", requestId, \"application/ssml+xml\", ssml));\n    }\n\n    fetchConnection() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (this.privConnectionConfigurationPromise !== undefined) {\n          return this.privConnectionConfigurationPromise.then(connection => {\n            if (connection.state() === ConnectionState.Disconnected) {\n              this.privConnectionId = null;\n              this.privConnectionConfigurationPromise = undefined;\n              return this.fetchConnection();\n            }\n\n            return this.privConnectionConfigurationPromise;\n          }, () => {\n            this.privConnectionId = null;\n            this.privConnectionConfigurationPromise = undefined;\n            return this.fetchConnection();\n          });\n        }\n\n        this.privConnectionConfigurationPromise = this.configureConnection();\n        return yield this.privConnectionConfigurationPromise;\n      });\n    } // Takes an established websocket connection to the endpoint and sends speech configuration information.\n\n\n    configureConnection() {\n      return __awaiter(this, void 0, void 0, function* () {\n        const connection = yield this.connectImpl();\n\n        if (this.configConnectionOverride !== undefined) {\n          return this.configConnectionOverride(connection);\n        }\n\n        yield this.sendSpeechServiceConfig(connection, this.privSynthesizerConfig.SpeechServiceConfig.serialize());\n        return connection;\n      });\n    }\n\n  }\n\n  SynthesisAdapterBase.telemetryDataEnabled = true; //# sourceMappingURL=SynthesisAdapterBase.js.map\n\n  return SynthesisAdapterBase;\n})();","map":null,"metadata":{},"sourceType":"module"}