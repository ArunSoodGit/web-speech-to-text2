{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\n/* eslint-disable max-classes-per-file */\nimport { AudioSourceErrorEvent, AudioStreamNodeAttachedEvent, AudioStreamNodeAttachingEvent, AudioStreamNodeDetachedEvent, AudioStreamNodeErrorEvent, ConnectionEstablishedEvent, ConnectionEstablishErrorEvent, ConnectionMessageReceivedEvent, ConnectionStartEvent } from \"../common/Exports\";\nimport { ConnectingToServiceEvent, RecognitionTriggeredEvent } from \"./RecognitionEvents\";\nexport class ServiceTelemetryListener {\n  constructor(requestId, audioSourceId, audioNodeId) {\n    this.privIsDisposed = false;\n    this.privListeningTriggerMetric = null;\n    this.privMicMetric = null;\n    this.privConnectionEstablishMetric = null;\n    this.privRequestId = requestId;\n    this.privAudioSourceId = audioSourceId;\n    this.privAudioNodeId = audioNodeId;\n    this.privReceivedMessages = {};\n    this.privPhraseLatencies = [];\n    this.privHypothesisLatencies = [];\n  }\n\n  phraseReceived(audioReceivedTime) {\n    if (audioReceivedTime > 0) {\n      // 0 indicates the time is unknown. Drop it.\n      this.privPhraseLatencies.push(Date.now() - audioReceivedTime);\n    }\n  }\n\n  hypothesisReceived(audioReceivedTime) {\n    if (audioReceivedTime > 0) {\n      // 0 indicates the time is unknown. Drop it.\n      this.privHypothesisLatencies.push(Date.now() - audioReceivedTime);\n    }\n  }\n\n  onEvent(e) {\n    if (this.privIsDisposed) {\n      return;\n    }\n\n    if (e instanceof RecognitionTriggeredEvent && e.requestId === this.privRequestId) {\n      this.privListeningTriggerMetric = {\n        End: e.eventTime,\n        Name: \"ListeningTrigger\",\n        Start: e.eventTime\n      };\n    }\n\n    if (e instanceof AudioStreamNodeAttachingEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {\n      this.privMicStartTime = e.eventTime;\n    }\n\n    if (e instanceof AudioStreamNodeAttachedEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {\n      this.privMicStartTime = e.eventTime;\n    }\n\n    if (e instanceof AudioSourceErrorEvent && e.audioSourceId === this.privAudioSourceId) {\n      if (!this.privMicMetric) {\n        this.privMicMetric = {\n          End: e.eventTime,\n          Error: e.error,\n          Name: \"Microphone\",\n          Start: this.privMicStartTime\n        };\n      }\n    }\n\n    if (e instanceof AudioStreamNodeErrorEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {\n      if (!this.privMicMetric) {\n        this.privMicMetric = {\n          End: e.eventTime,\n          Error: e.error,\n          Name: \"Microphone\",\n          Start: this.privMicStartTime\n        };\n      }\n    }\n\n    if (e instanceof AudioStreamNodeDetachedEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {\n      if (!this.privMicMetric) {\n        this.privMicMetric = {\n          End: e.eventTime,\n          Name: \"Microphone\",\n          Start: this.privMicStartTime\n        };\n      }\n    }\n\n    if (e instanceof ConnectingToServiceEvent && e.requestId === this.privRequestId) {\n      this.privConnectionId = e.sessionId;\n    }\n\n    if (e instanceof ConnectionStartEvent && e.connectionId === this.privConnectionId) {\n      this.privConnectionStartTime = e.eventTime;\n    }\n\n    if (e instanceof ConnectionEstablishedEvent && e.connectionId === this.privConnectionId) {\n      if (!this.privConnectionEstablishMetric) {\n        this.privConnectionEstablishMetric = {\n          End: e.eventTime,\n          Id: this.privConnectionId,\n          Name: \"Connection\",\n          Start: this.privConnectionStartTime\n        };\n      }\n    }\n\n    if (e instanceof ConnectionEstablishErrorEvent && e.connectionId === this.privConnectionId) {\n      if (!this.privConnectionEstablishMetric) {\n        this.privConnectionEstablishMetric = {\n          End: e.eventTime,\n          Error: this.getConnectionError(e.statusCode),\n          Id: this.privConnectionId,\n          Name: \"Connection\",\n          Start: this.privConnectionStartTime\n        };\n      }\n    }\n\n    if (e instanceof ConnectionMessageReceivedEvent && e.connectionId === this.privConnectionId) {\n      if (e.message && e.message.headers && e.message.headers.path) {\n        if (!this.privReceivedMessages[e.message.headers.path]) {\n          this.privReceivedMessages[e.message.headers.path] = new Array();\n        }\n\n        const maxMessagesToSend = 50;\n\n        if (this.privReceivedMessages[e.message.headers.path].length < maxMessagesToSend) {\n          this.privReceivedMessages[e.message.headers.path].push(e.networkReceivedTime);\n        }\n      }\n    }\n  }\n\n  getTelemetry() {\n    const metrics = new Array();\n\n    if (this.privListeningTriggerMetric) {\n      metrics.push(this.privListeningTriggerMetric);\n    }\n\n    if (this.privMicMetric) {\n      metrics.push(this.privMicMetric);\n    }\n\n    if (this.privConnectionEstablishMetric) {\n      metrics.push(this.privConnectionEstablishMetric);\n    }\n\n    if (this.privPhraseLatencies.length > 0) {\n      metrics.push({\n        PhraseLatencyMs: this.privPhraseLatencies\n      });\n    }\n\n    if (this.privHypothesisLatencies.length > 0) {\n      metrics.push({\n        FirstHypothesisLatencyMs: this.privHypothesisLatencies\n      });\n    }\n\n    const telemetry = {\n      Metrics: metrics,\n      ReceivedMessages: this.privReceivedMessages\n    };\n    const json = JSON.stringify(telemetry); // We dont want to send the same telemetry again. So clean those out.\n\n    this.privReceivedMessages = {};\n    this.privListeningTriggerMetric = null;\n    this.privMicMetric = null;\n    this.privConnectionEstablishMetric = null;\n    this.privPhraseLatencies = [];\n    this.privHypothesisLatencies = [];\n    return json;\n  } // Determines if there are any telemetry events to send to the service.\n\n\n  get hasTelemetry() {\n    return Object.keys(this.privReceivedMessages).length !== 0 || this.privListeningTriggerMetric !== null || this.privMicMetric !== null || this.privConnectionEstablishMetric !== null || this.privPhraseLatencies.length !== 0 || this.privHypothesisLatencies.length !== 0;\n  }\n\n  dispose() {\n    this.privIsDisposed = true;\n  }\n\n  getConnectionError(statusCode) {\n    /*\n    -- Websocket status codes --\n    NormalClosure = 1000,\n    EndpointUnavailable = 1001,\n    ProtocolError = 1002,\n    InvalidMessageType = 1003,\n    Empty = 1005,\n    InvalidPayloadData = 1007,\n    PolicyViolation = 1008,\n    MessageTooBig = 1009,\n    MandatoryExtension = 1010,\n    InternalServerError = 1011\n    */\n    switch (statusCode) {\n      case 400:\n      case 1002:\n      case 1003:\n      case 1005:\n      case 1007:\n      case 1008:\n      case 1009:\n        return \"BadRequest\";\n\n      case 401:\n        return \"Unauthorized\";\n\n      case 403:\n        return \"Forbidden\";\n\n      case 503:\n      case 1001:\n        return \"ServerUnavailable\";\n\n      case 500:\n      case 1011:\n        return \"ServerError\";\n\n      case 408:\n      case 504:\n        return \"Timeout\";\n\n      default:\n        return \"statuscode:\" + statusCode.toString();\n    }\n  }\n\n} //# sourceMappingURL=ServiceTelemetryListener.Internal.js.map","map":null,"metadata":{},"sourceType":"module"}