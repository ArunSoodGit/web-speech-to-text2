{"ast":null,"code":"/* eslint-disable import/order */\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport * as tls from \"tls\";\nimport * as ocsp from \"../../external/ocsp/ocsp\";\nimport { Events, OCSPCacheEntryExpiredEvent, OCSPCacheEntryNeedsRefreshEvent, OCSPCacheFetchErrorEvent, OCSPCacheHitEvent, OCSPCacheMissEvent, OCSPCacheUpdateCompleteEvent, OCSPCacheUpdateNeededEvent, OCSPDiskCacheHitEvent, OCSPDiskCacheStoreEvent, OCSPMemoryCacheHitEvent, OCSPMemoryCacheStoreEvent, OCSPResponseRetrievedEvent, OCSPStapleReceivedEvent, OCSPVerificationFailedEvent } from \"../common/Exports\";\nimport Agent from \"agent-base\"; // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n\nimport Cache from \"async-disk-cache\";\nimport HttpsProxyAgent from \"https-proxy-agent\";\nimport * as net from \"net\";\nimport { OCSPCacheUpdateErrorEvent } from \"../common/OCSPEvents\";\nexport let CertCheckAgent = /*#__PURE__*/(() => {\n  class CertCheckAgent {\n    constructor(proxyInfo) {\n      if (!!proxyInfo) {\n        this.privProxyInfo = proxyInfo;\n      } // Initialize this here to allow tests to set the env variable before the cache is constructed.\n\n\n      if (!CertCheckAgent.privDiskCache) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call\n        CertCheckAgent.privDiskCache = new Cache(\"microsoft-cognitiveservices-speech-sdk-cache\", {\n          supportBuffer: true,\n          location: typeof process !== \"undefined\" && !!process.env.SPEECH_OCSP_CACHE_ROOT ? process.env.SPEECH_OCSP_CACHE_ROOT : undefined\n        });\n      }\n    } // Test hook to force the disk cache to be recreated.\n\n\n    static forceReinitDiskCache() {\n      CertCheckAgent.privDiskCache = undefined;\n      CertCheckAgent.privMemCache = {};\n    } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    GetAgent(disableStapling) {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const agent = new Agent.Agent(this.CreateConnection);\n\n      if (this.privProxyInfo !== undefined && this.privProxyInfo.HostName !== undefined && this.privProxyInfo.Port > 0) {\n        const proxyName = \"privProxyInfo\"; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n        agent[proxyName] = this.privProxyInfo;\n      }\n\n      return agent;\n    }\n\n    static GetProxyAgent(proxyInfo) {\n      const httpProxyOptions = {\n        host: proxyInfo.HostName,\n        port: proxyInfo.Port\n      };\n\n      if (!!proxyInfo.UserName) {\n        httpProxyOptions.headers = {\n          \"Proxy-Authentication\": \"Basic \" + new Buffer(`${proxyInfo.UserName}:${proxyInfo.Password === undefined ? \"\" : proxyInfo.Password}`).toString(\"base64\")\n        };\n      } else {\n        httpProxyOptions.headers = {};\n      }\n\n      httpProxyOptions.headers.requestOCSP = \"true\";\n      const httpProxyAgent = new HttpsProxyAgent(httpProxyOptions);\n      return httpProxyAgent;\n    }\n\n    static OCSPCheck(socketPromise, proxyInfo) {\n      return __awaiter(this, void 0, void 0, function* () {\n        let ocspRequest;\n        let stapling;\n        let resolved = false;\n        const socket = yield socketPromise;\n        socket.cork();\n        const tlsSocket = socket;\n        return new Promise((resolve, reject) => {\n          socket.on(\"OCSPResponse\", data => {\n            if (!!data) {\n              this.onEvent(new OCSPStapleReceivedEvent());\n              stapling = data;\n            }\n          });\n          socket.on(\"error\", error => {\n            if (!resolved) {\n              resolved = true;\n              socket.destroy();\n              reject(error);\n            }\n          }); // eslint-disable-next-line @typescript-eslint/no-misused-promises, @typescript-eslint/explicit-function-return-type\n\n          tlsSocket.on(\"secure\", () => __awaiter(this, void 0, void 0, function* () {\n            const peer = tlsSocket.getPeerCertificate(true);\n\n            try {\n              const issuer = yield this.GetIssuer(peer); // We always need a request to verify the response.\n\n              ocspRequest = ocsp.request.generate(peer.raw, issuer.raw); // Do we have a result for this certificate in our memory cache?\n\n              const sig = ocspRequest.id.toString(\"hex\"); // Stapled response trumps cached response.\n\n              if (!stapling) {\n                const cacheEntry = yield CertCheckAgent.GetResponseFromCache(sig, ocspRequest, proxyInfo);\n                stapling = cacheEntry;\n              }\n\n              yield this.VerifyOCSPResponse(stapling, ocspRequest, proxyInfo);\n              socket.uncork();\n              resolved = true;\n              resolve(socket);\n            } catch (e) {\n              socket.destroy();\n              resolved = true;\n              reject(e);\n            }\n          }));\n        });\n      });\n    }\n\n    static GetIssuer(peer) {\n      if (peer.issuerCertificate) {\n        return Promise.resolve(peer.issuerCertificate);\n      }\n\n      return new Promise((resolve, reject) => {\n        const ocspAgent = new ocsp.Agent({});\n        ocspAgent.fetchIssuer(peer, null, (error, value) => {\n          if (!!error) {\n            reject(error);\n            return;\n          }\n\n          resolve(value);\n        });\n      });\n    }\n\n    static GetResponseFromCache(signature, ocspRequest, proxyInfo) {\n      return __awaiter(this, void 0, void 0, function* () {\n        let cachedResponse = CertCheckAgent.privMemCache[signature];\n\n        if (!!cachedResponse) {\n          this.onEvent(new OCSPMemoryCacheHitEvent(signature));\n        } // Do we have a result for this certificate on disk in %TMP%?\n\n\n        if (!cachedResponse) {\n          try {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n            const diskCacheResponse = yield CertCheckAgent.privDiskCache.get(signature);\n\n            if (!!diskCacheResponse.isCached) {\n              CertCheckAgent.onEvent(new OCSPDiskCacheHitEvent(signature));\n              CertCheckAgent.StoreMemoryCacheEntry(signature, diskCacheResponse.value);\n              cachedResponse = diskCacheResponse.value;\n            }\n          } catch (error) {\n            cachedResponse = null;\n          }\n        }\n\n        if (!cachedResponse) {\n          return cachedResponse;\n        }\n\n        try {\n          const cachedOcspResponse = ocsp.utils.parseResponse(cachedResponse);\n          const responseValue = cachedOcspResponse.value;\n          const tbsData = responseValue.tbsResponseData;\n\n          if (tbsData.responses.length < 1) {\n            this.onEvent(new OCSPCacheFetchErrorEvent(signature, \"Not enough data in cached response\"));\n            return;\n          }\n\n          const cachedStartTime = tbsData.responses[0].thisUpdate;\n          const cachedNextTime = tbsData.responses[0].nextUpdate;\n\n          if (cachedNextTime < Date.now() + this.testTimeOffset - 60000) {\n            // Cached entry has expired.\n            this.onEvent(new OCSPCacheEntryExpiredEvent(signature, cachedNextTime));\n            cachedResponse = null;\n          } else {\n            // If we're within one day of the next update, or 50% of the way through the validity period,\n            // background an update to the cache.\n            const minUpdate = Math.min(24 * 60 * 60 * 1000, (cachedNextTime - cachedStartTime) / 2);\n\n            if (cachedNextTime - (Date.now() + this.testTimeOffset) < minUpdate) {\n              this.onEvent(new OCSPCacheEntryNeedsRefreshEvent(signature, cachedStartTime, cachedNextTime));\n              this.UpdateCache(ocspRequest, proxyInfo).catch(error => {\n                // Well, not much we can do here.\n                this.onEvent(new OCSPCacheUpdateErrorEvent(signature, error.toString()));\n              });\n            } else {\n              this.onEvent(new OCSPCacheHitEvent(signature, cachedStartTime, cachedNextTime));\n            }\n          }\n        } catch (error) {\n          this.onEvent(new OCSPCacheFetchErrorEvent(signature, error));\n          cachedResponse = null;\n        }\n\n        if (!cachedResponse) {\n          this.onEvent(new OCSPCacheMissEvent(signature));\n        }\n\n        return cachedResponse;\n      });\n    }\n\n    static VerifyOCSPResponse(cacheValue, ocspRequest, proxyInfo) {\n      return __awaiter(this, void 0, void 0, function* () {\n        let ocspResponse = cacheValue; // Do we have a valid response?\n\n        if (!ocspResponse) {\n          ocspResponse = yield CertCheckAgent.GetOCSPResponse(ocspRequest, proxyInfo);\n        }\n\n        return new Promise((resolve, reject) => {\n          ocsp.verify({\n            request: ocspRequest,\n            response: ocspResponse\n          }, error => {\n            if (!!error) {\n              CertCheckAgent.onEvent(new OCSPVerificationFailedEvent(ocspRequest.id.toString(\"hex\"), error)); // Bad Cached Value? One more try without the cache.\n\n              if (!!cacheValue) {\n                this.VerifyOCSPResponse(null, ocspRequest, proxyInfo).then(() => {\n                  resolve();\n                }, error => {\n                  reject(error);\n                });\n              } else {\n                reject(error);\n              }\n            } else {\n              if (!cacheValue) {\n                CertCheckAgent.StoreCacheEntry(ocspRequest.id.toString(\"hex\"), ocspResponse);\n              }\n\n              resolve();\n            }\n          });\n        });\n      });\n    }\n\n    static UpdateCache(req, proxyInfo) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const signature = req.id.toString(\"hex\");\n        this.onEvent(new OCSPCacheUpdateNeededEvent(signature));\n        const rawResponse = yield this.GetOCSPResponse(req, proxyInfo);\n        this.StoreCacheEntry(signature, rawResponse);\n        this.onEvent(new OCSPCacheUpdateCompleteEvent(req.id.toString(\"hex\")));\n      });\n    }\n\n    static StoreCacheEntry(sig, rawResponse) {\n      this.StoreMemoryCacheEntry(sig, rawResponse);\n      this.StoreDiskCacheEntry(sig, rawResponse);\n    }\n\n    static StoreMemoryCacheEntry(sig, rawResponse) {\n      this.privMemCache[sig] = rawResponse;\n      this.onEvent(new OCSPMemoryCacheStoreEvent(sig));\n    }\n\n    static StoreDiskCacheEntry(sig, rawResponse) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n      this.privDiskCache.set(sig, rawResponse).then(() => {\n        this.onEvent(new OCSPDiskCacheStoreEvent(sig));\n      });\n    }\n\n    static GetOCSPResponse(req, proxyInfo) {\n      const ocspMethod = \"1.3.6.1.5.5.7.48.1\";\n      let options = {};\n\n      if (!!proxyInfo) {\n        const agent = CertCheckAgent.GetProxyAgent(proxyInfo);\n        options.agent = agent;\n      }\n\n      return new Promise((resolve, reject) => {\n        ocsp.utils.getAuthorityInfo(req.cert, ocspMethod, (error, uri) => {\n          if (error) {\n            reject(error);\n            return;\n          }\n\n          const url = new URL(uri);\n          options = Object.assign(Object.assign({}, options), {\n            host: url.host,\n            protocol: url.protocol,\n            port: url.port,\n            path: url.pathname,\n            hostname: url.host\n          });\n          ocsp.utils.getResponse(options, req.data, (error, raw) => {\n            if (error) {\n              reject(error);\n              return;\n            }\n\n            const certID = req.certID;\n            this.onEvent(new OCSPResponseRetrievedEvent(certID.toString(\"hex\")));\n            resolve(raw);\n          });\n        });\n      });\n    }\n\n    static onEvent(event) {\n      Events.instance.onEvent(event);\n    }\n\n    CreateConnection(request, options) {\n      const enableOCSP = typeof process !== \"undefined\" && process.env.NODE_TLS_REJECT_UNAUTHORIZED !== \"0\" && process.env.SPEECH_CONDUCT_OCSP_CHECK !== \"0\" && options.secureEndpoint;\n      let socketPromise;\n      options = Object.assign(Object.assign({}, options), {\n        requestOCSP: !CertCheckAgent.forceDisableOCSPStapling,\n        servername: options.host\n      });\n\n      if (!!this.privProxyInfo) {\n        const httpProxyAgent = CertCheckAgent.GetProxyAgent(this.privProxyInfo);\n        const baseAgent = httpProxyAgent;\n        socketPromise = new Promise((resolve, reject) => {\n          baseAgent.callback(request, options, (error, socket) => {\n            if (!!error) {\n              reject(error);\n            } else {\n              resolve(socket);\n            }\n          });\n        });\n      } else {\n        if (!!options.secureEndpoint) {\n          socketPromise = Promise.resolve(tls.connect(options));\n        } else {\n          socketPromise = Promise.resolve(net.connect(options));\n        }\n      }\n\n      if (!!enableOCSP) {\n        return CertCheckAgent.OCSPCheck(socketPromise, this.privProxyInfo);\n      } else {\n        return socketPromise;\n      }\n    }\n\n  }\n\n  // Test hook to enable forcing expiration / refresh to happen.\n  //# sourceMappingURL=CertChecks.js.map\n  CertCheckAgent.testTimeOffset = 0; // Test hook to disable stapling for cache testing.\n\n  CertCheckAgent.forceDisableOCSPStapling = false; // An in memory cache for recived responses.\n\n  CertCheckAgent.privMemCache = {};\n  return CertCheckAgent;\n})();","map":null,"metadata":{},"sourceType":"module"}