{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { RestMessageAdapter, RestRequestType } from \"../../common.browser/Exports\";\nimport { Contracts } from \"../../sdk/Contracts\";\nimport { PropertyId } from \"../../sdk/Exports\";\nimport { ConversationConnectionConfig } from \"./ConversationConnectionConfig\";\nexport class ConversationManager {\n  constructor() {\n    //\n    this.privRequestParams = ConversationConnectionConfig.configParams;\n    this.privErrors = ConversationConnectionConfig.restErrors;\n    this.privHost = ConversationConnectionConfig.host;\n    this.privApiVersion = ConversationConnectionConfig.apiVersion;\n    this.privRestPath = ConversationConnectionConfig.restPath;\n    this.privRestAdapter = new RestMessageAdapter({});\n  }\n  /**\n   * Make a POST request to the Conversation Manager service endpoint to create or join a conversation.\n   * @param args\n   * @param conversationCode\n   * @param callback\n   * @param errorCallback\n   */\n\n\n  createOrJoin(args, conversationCode, cb, err) {\n    try {\n      Contracts.throwIfNullOrUndefined(args, \"args\");\n      const languageCode = args.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage, ConversationConnectionConfig.defaultLanguageCode);\n      const nickname = args.getProperty(PropertyId.ConversationTranslator_Name, \"conversation_host\");\n      const endpointHost = args.getProperty(PropertyId.ConversationTranslator_Host, this.privHost);\n      const correlationId = args.getProperty(PropertyId.ConversationTranslator_CorrelationId);\n      const subscriptionKey = args.getProperty(PropertyId.SpeechServiceConnection_Key);\n      const subscriptionRegion = args.getProperty(PropertyId.SpeechServiceConnection_Region);\n      const authToken = args.getProperty(PropertyId.SpeechServiceAuthorization_Token);\n      Contracts.throwIfNullOrWhitespace(languageCode, \"languageCode\");\n      Contracts.throwIfNullOrWhitespace(nickname, \"nickname\");\n      Contracts.throwIfNullOrWhitespace(endpointHost, \"endpointHost\");\n      const queryParams = {};\n      queryParams[this.privRequestParams.apiVersion] = this.privApiVersion;\n      queryParams[this.privRequestParams.languageCode] = languageCode;\n      queryParams[this.privRequestParams.nickname] = nickname;\n      const headers = {};\n\n      if (correlationId) {\n        headers[this.privRequestParams.correlationId] = correlationId;\n      }\n\n      headers[this.privRequestParams.clientAppId] = ConversationConnectionConfig.clientAppId;\n\n      if (conversationCode !== undefined) {\n        queryParams[this.privRequestParams.roomId] = conversationCode;\n      } else {\n        Contracts.throwIfNullOrUndefined(subscriptionRegion, this.privErrors.authInvalidSubscriptionRegion);\n        headers[this.privRequestParams.subscriptionRegion] = subscriptionRegion;\n\n        if (subscriptionKey) {\n          headers[this.privRequestParams.subscriptionKey] = subscriptionKey;\n        } else if (authToken) {\n          headers[this.privRequestParams.authorization] = `Bearer ${authToken}`;\n        } else {\n          Contracts.throwIfNullOrUndefined(subscriptionKey, this.privErrors.authInvalidSubscriptionKey);\n        }\n      }\n\n      const config = {};\n      config.headers = headers;\n      this.privRestAdapter.options = config;\n      const endpoint = `https://${endpointHost}${this.privRestPath}`; // TODO: support a proxy and certificate validation\n\n      this.privRestAdapter.request(RestRequestType.Post, endpoint, queryParams, null).then(response => {\n        const requestId = RestMessageAdapter.extractHeaderValue(this.privRequestParams.requestId, response.headers);\n\n        if (!response.ok) {\n          if (!!err) {\n            // get the error\n            let errorMessage = this.privErrors.invalidCreateJoinConversationResponse.replace(\"{status}\", response.status.toString());\n            let errMessageRaw;\n\n            try {\n              errMessageRaw = JSON.parse(response.data);\n              errorMessage += ` [${errMessageRaw.error.code}: ${errMessageRaw.error.message}]`;\n            } catch (e) {\n              errorMessage += ` [${response.data}]`;\n            }\n\n            if (requestId) {\n              errorMessage += ` ${requestId}`;\n            }\n\n            err(errorMessage);\n          }\n\n          return;\n        }\n\n        const conversation = JSON.parse(response.data);\n\n        if (conversation) {\n          conversation.requestId = requestId;\n        }\n\n        if (!!cb) {\n          try {\n            cb(conversation);\n          } catch (e) {\n            if (!!err) {\n              err(e);\n            }\n          }\n\n          cb = undefined;\n        } // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n      }).catch(() => {});\n    } catch (error) {\n      if (!!err) {\n        if (error instanceof Error) {\n          const typedError = error;\n          err(typedError.name + \": \" + typedError.message);\n        } else {\n          err(error);\n        }\n      }\n    }\n  }\n  /**\n   * Make a DELETE request to the Conversation Manager service endpoint to leave the conversation.\n   * @param args\n   * @param sessionToken\n   * @param callback\n   */\n\n\n  leave(args, sessionToken) {\n    return new Promise((resolve, reject) => {\n      try {\n        Contracts.throwIfNullOrUndefined(args, this.privErrors.invalidArgs.replace(\"{arg}\", \"config\"));\n        Contracts.throwIfNullOrWhitespace(sessionToken, this.privErrors.invalidArgs.replace(\"{arg}\", \"token\"));\n        const endpointHost = args.getProperty(PropertyId.ConversationTranslator_Host, this.privHost);\n        const correlationId = args.getProperty(PropertyId.ConversationTranslator_CorrelationId);\n        const queryParams = {};\n        queryParams[this.privRequestParams.apiVersion] = this.privApiVersion;\n        queryParams[this.privRequestParams.sessionToken] = sessionToken;\n        const headers = {};\n\n        if (correlationId) {\n          headers[this.privRequestParams.correlationId] = correlationId;\n        }\n\n        const config = {};\n        config.headers = headers;\n        this.privRestAdapter.options = config;\n        const endpoint = `https://${endpointHost}${this.privRestPath}`; // TODO: support a proxy and certificate validation\n\n        this.privRestAdapter.request(RestRequestType.Delete, endpoint, queryParams, null).then(response => {\n          if (!response.ok) {// ignore errors on delete\n          }\n\n          resolve(); // eslint-disable-next-line @typescript-eslint/no-empty-function\n        }).catch(() => {});\n      } catch (error) {\n        if (error instanceof Error) {\n          const typedError = error;\n          reject(typedError.name + \": \" + typedError.message);\n        } else {\n          reject(error);\n        }\n      }\n    });\n  }\n\n} //# sourceMappingURL=ConversationManager.js.map","map":null,"metadata":{},"sourceType":"module"}