{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}; // Node.JS specific web socket / browser support.\n\n\nimport ws from \"ws\";\nimport { HeaderNames } from \"../common.speech/HeaderNames\";\nimport { ArgumentNullError, BackgroundEvent, ConnectionClosedEvent, ConnectionErrorEvent, ConnectionEstablishedEvent, ConnectionMessageReceivedEvent, ConnectionMessageSentEvent, ConnectionOpenResponse, ConnectionStartEvent, ConnectionState, Deferred, Events, EventSource, MessageType, Queue, RawWebsocketMessage } from \"../common/Exports\";\nimport { CertCheckAgent } from \"./CertChecks\";\nexport let WebsocketMessageAdapter = /*#__PURE__*/(() => {\n  class WebsocketMessageAdapter {\n    constructor(uri, connectionId, messageFormatter, proxyInfo, headers, enableCompression) {\n      if (!uri) {\n        throw new ArgumentNullError(\"uri\");\n      }\n\n      if (!messageFormatter) {\n        throw new ArgumentNullError(\"messageFormatter\");\n      }\n\n      this.proxyInfo = proxyInfo;\n      this.privConnectionEvents = new EventSource();\n      this.privConnectionId = connectionId;\n      this.privMessageFormatter = messageFormatter;\n      this.privConnectionState = ConnectionState.None;\n      this.privUri = uri;\n      this.privHeaders = headers;\n      this.privEnableCompression = enableCompression; // Add the connection ID to the headers\n\n      this.privHeaders[HeaderNames.ConnectionId] = this.privConnectionId;\n      this.privLastErrorReceived = \"\";\n    }\n\n    get state() {\n      return this.privConnectionState;\n    }\n\n    open() {\n      if (this.privConnectionState === ConnectionState.Disconnected) {\n        return Promise.reject(`Cannot open a connection that is in ${this.privConnectionState} state`);\n      }\n\n      if (this.privConnectionEstablishDeferral) {\n        return this.privConnectionEstablishDeferral.promise;\n      }\n\n      this.privConnectionEstablishDeferral = new Deferred();\n      this.privCertificateValidatedDeferral = new Deferred();\n      this.privConnectionState = ConnectionState.Connecting;\n\n      try {\n        if (typeof WebSocket !== \"undefined\" && !WebsocketMessageAdapter.forceNpmWebSocket) {\n          // Browser handles cert checks.\n          this.privCertificateValidatedDeferral.resolve();\n          this.privWebsocketClient = new WebSocket(this.privUri);\n        } else {\n          const options = {\n            headers: this.privHeaders,\n            perMessageDeflate: this.privEnableCompression\n          }; // The ocsp library will handle validation for us and fail the connection if needed.\n\n          this.privCertificateValidatedDeferral.resolve();\n          const checkAgent = new CertCheckAgent(this.proxyInfo);\n          options.agent = checkAgent.GetAgent(); // Workaround for https://github.com/microsoft/cognitive-services-speech-sdk-js/issues/465\n          // Which is root caused by https://github.com/TooTallNate/node-agent-base/issues/61\n\n          const uri = new URL(this.privUri);\n          let protocol = uri.protocol;\n\n          if ((protocol === null || protocol === void 0 ? void 0 : protocol.toLocaleLowerCase()) === \"wss:\") {\n            protocol = \"https:\";\n          } else if ((protocol === null || protocol === void 0 ? void 0 : protocol.toLocaleLowerCase()) === \"ws:\") {\n            protocol = \"http:\";\n          } // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n\n          options.agent.protocol = protocol;\n          this.privWebsocketClient = new ws(this.privUri, options);\n        }\n\n        this.privWebsocketClient.binaryType = \"arraybuffer\";\n        this.privReceivingMessageQueue = new Queue();\n        this.privDisconnectDeferral = new Deferred();\n        this.privSendMessageQueue = new Queue();\n        this.processSendQueue().catch(reason => {\n          Events.instance.onEvent(new BackgroundEvent(reason));\n        });\n      } catch (error) {\n        this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(500, error));\n        return this.privConnectionEstablishDeferral.promise;\n      }\n\n      this.onEvent(new ConnectionStartEvent(this.privConnectionId, this.privUri));\n\n      this.privWebsocketClient.onopen = () => {\n        this.privCertificateValidatedDeferral.promise.then(() => {\n          this.privConnectionState = ConnectionState.Connected;\n          this.onEvent(new ConnectionEstablishedEvent(this.privConnectionId));\n          this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(200, \"\"));\n        }, error => {\n          this.privConnectionEstablishDeferral.reject(error);\n        });\n      };\n\n      this.privWebsocketClient.onerror = e => {\n        this.onEvent(new ConnectionErrorEvent(this.privConnectionId, e.message, e.type));\n        this.privLastErrorReceived = e.message;\n      };\n\n      this.privWebsocketClient.onclose = e => {\n        if (this.privConnectionState === ConnectionState.Connecting) {\n          this.privConnectionState = ConnectionState.Disconnected; // this.onEvent(new ConnectionEstablishErrorEvent(this.connectionId, e.code, e.reason));\n\n          this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(e.code, e.reason + \" \" + this.privLastErrorReceived));\n        } else {\n          this.privConnectionState = ConnectionState.Disconnected;\n          this.privWebsocketClient = null;\n          this.onEvent(new ConnectionClosedEvent(this.privConnectionId, e.code, e.reason));\n        }\n\n        this.onClose(e.code, e.reason).catch(reason => {\n          Events.instance.onEvent(new BackgroundEvent(reason));\n        });\n      };\n\n      this.privWebsocketClient.onmessage = e => {\n        const networkReceivedTime = new Date().toISOString();\n\n        if (this.privConnectionState === ConnectionState.Connected) {\n          const deferred = new Deferred(); // let id = ++this.idCounter;\n\n          this.privReceivingMessageQueue.enqueueFromPromise(deferred.promise);\n\n          if (e.data instanceof ArrayBuffer) {\n            const rawMessage = new RawWebsocketMessage(MessageType.Binary, e.data);\n            this.privMessageFormatter.toConnectionMessage(rawMessage).then(connectionMessage => {\n              this.onEvent(new ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));\n              deferred.resolve(connectionMessage);\n            }, error => {\n              // TODO: Events for these ?\n              deferred.reject(`Invalid binary message format. Error: ${error}`);\n            });\n          } else {\n            const rawMessage = new RawWebsocketMessage(MessageType.Text, e.data);\n            this.privMessageFormatter.toConnectionMessage(rawMessage).then(connectionMessage => {\n              this.onEvent(new ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));\n              deferred.resolve(connectionMessage);\n            }, error => {\n              // TODO: Events for these ?\n              deferred.reject(`Invalid text message format. Error: ${error}`);\n            });\n          }\n        }\n      };\n\n      return this.privConnectionEstablishDeferral.promise;\n    }\n\n    send(message) {\n      if (this.privConnectionState !== ConnectionState.Connected) {\n        return Promise.reject(`Cannot send on connection that is in ${ConnectionState[this.privConnectionState]} state`);\n      }\n\n      const messageSendStatusDeferral = new Deferred();\n      const messageSendDeferral = new Deferred();\n      this.privSendMessageQueue.enqueueFromPromise(messageSendDeferral.promise);\n      this.privMessageFormatter.fromConnectionMessage(message).then(rawMessage => {\n        messageSendDeferral.resolve({\n          Message: message,\n          RawWebsocketMessage: rawMessage,\n          sendStatusDeferral: messageSendStatusDeferral\n        });\n      }, error => {\n        messageSendDeferral.reject(`Error formatting the message. ${error}`);\n      });\n      return messageSendStatusDeferral.promise;\n    }\n\n    read() {\n      if (this.privConnectionState !== ConnectionState.Connected) {\n        return Promise.reject(`Cannot read on connection that is in ${this.privConnectionState} state`);\n      }\n\n      return this.privReceivingMessageQueue.dequeue();\n    }\n\n    close(reason) {\n      if (this.privWebsocketClient) {\n        if (this.privConnectionState !== ConnectionState.Disconnected) {\n          this.privWebsocketClient.close(1000, reason ? reason : \"Normal closure by client\");\n        }\n      } else {\n        return Promise.resolve();\n      }\n\n      return this.privDisconnectDeferral.promise;\n    }\n\n    get events() {\n      return this.privConnectionEvents;\n    }\n\n    sendRawMessage(sendItem) {\n      try {\n        // indicates we are draining the queue and it came with no message;\n        if (!sendItem) {\n          return Promise.resolve();\n        }\n\n        this.onEvent(new ConnectionMessageSentEvent(this.privConnectionId, new Date().toISOString(), sendItem.Message)); // add a check for the ws readystate in order to stop the red console error 'WebSocket is already in CLOSING or CLOSED state' appearing\n\n        if (this.isWebsocketOpen) {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n          this.privWebsocketClient.send(sendItem.RawWebsocketMessage.payload);\n        } else {\n          return Promise.reject(\"websocket send error: Websocket not ready \" + this.privConnectionId + \" \" + sendItem.Message.id + \" \" + new Error().stack);\n        }\n\n        return Promise.resolve();\n      } catch (e) {\n        return Promise.reject(`websocket send error: ${e}`);\n      }\n    }\n\n    onClose(code, reason) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const closeReason = `Connection closed. ${code}: ${reason}`;\n        this.privConnectionState = ConnectionState.Disconnected;\n        this.privDisconnectDeferral.resolve();\n        yield this.privReceivingMessageQueue.drainAndDispose(() => {// TODO: Events for these ?\n          // Logger.instance.onEvent(new LoggingEvent(LogType.Warning, null, `Failed to process received message. Reason: ${closeReason}, Message: ${JSON.stringify(pendingReceiveItem)}`));\n        }, closeReason);\n        yield this.privSendMessageQueue.drainAndDispose(pendingSendItem => {\n          pendingSendItem.sendStatusDeferral.reject(closeReason);\n        }, closeReason);\n      });\n    }\n\n    processSendQueue() {\n      return __awaiter(this, void 0, void 0, function* () {\n        while (true) {\n          const itemToSend = this.privSendMessageQueue.dequeue();\n          const sendItem = yield itemToSend; // indicates we are draining the queue and it came with no message;\n\n          if (!sendItem) {\n            return;\n          }\n\n          try {\n            yield this.sendRawMessage(sendItem);\n            sendItem.sendStatusDeferral.resolve();\n          } catch (sendError) {\n            sendItem.sendStatusDeferral.reject(sendError);\n          }\n        }\n      });\n    }\n\n    onEvent(event) {\n      this.privConnectionEvents.onEvent(event);\n      Events.instance.onEvent(event);\n    }\n\n    get isWebsocketOpen() {\n      return this.privWebsocketClient && this.privWebsocketClient.readyState === this.privWebsocketClient.OPEN;\n    }\n\n  }\n\n  WebsocketMessageAdapter.forceNpmWebSocket = false; //# sourceMappingURL=WebsocketMessageAdapter.js.map\n\n  return WebsocketMessageAdapter;\n})();","map":null,"metadata":{},"sourceType":"module"}