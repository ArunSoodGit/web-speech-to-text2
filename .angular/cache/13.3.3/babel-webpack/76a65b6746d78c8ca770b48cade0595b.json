{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ReplayableAudioNode } from \"../common.browser/Exports\";\nimport { SendingAgentContextMessageEvent } from \"../common/DialogEvents\";\nimport { BackgroundEvent, createGuid, createNoDashGuid, Deferred, Events, EventSource, MessageType, ServiceEvent } from \"../common/Exports\";\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat\";\nimport { ActivityReceivedEventArgs, CancellationErrorCode, CancellationReason, DialogServiceConfig, PropertyCollection, PropertyId, RecognitionEventArgs, ResultReason, SessionEventArgs, SpeechRecognitionCanceledEventArgs, SpeechRecognitionEventArgs, SpeechRecognitionResult, TurnStatusReceivedEventArgs } from \"../sdk/Exports\";\nimport { DialogServiceTurnStateManager } from \"./DialogServiceTurnStateManager\";\nimport { CancellationErrorCodePropertyName, EnumTranslation, RecognitionStatus, ServiceRecognizerBase, SimpleSpeechPhrase, SpeechDetected, SpeechHypothesis, SpeechKeyword } from \"./Exports\";\nimport { ActivityPayloadResponse } from \"./ServiceMessages/ActivityResponsePayload\";\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\nexport class DialogServiceAdapter extends ServiceRecognizerBase {\n  constructor(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector) {\n    super(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector);\n    this.privEvents = new EventSource();\n    this.privDialogServiceConnector = dialogServiceConnector;\n\n    this.receiveMessageOverride = () => this.receiveDialogMessageOverride();\n\n    this.privTurnStateManager = new DialogServiceTurnStateManager();\n\n    this.recognizeOverride = (recoMode, successCallback, errorCallback) => this.listenOnce(recoMode, successCallback, errorCallback);\n\n    this.postConnectImplOverride = connection => this.dialogConnectImpl(connection);\n\n    this.configConnectionOverride = connection => this.configConnection(connection);\n\n    this.disconnectOverride = () => this.privDisconnect();\n\n    this.privDialogAudioSource = audioSource;\n    this.agentConfigSent = false;\n    this.privLastResult = null;\n    this.connectionEvents.attach(connectionEvent => {\n      if (connectionEvent.name === \"ConnectionClosedEvent\") {\n        this.terminateMessageLoop = true;\n      }\n    });\n  }\n\n  sendMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const interactionGuid = createGuid();\n      const requestId = createNoDashGuid();\n      const agentMessage = {\n        context: {\n          interactionId: interactionGuid\n        },\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        messagePayload: JSON.parse(message),\n        version: 0.5\n      };\n      const agentMessageJson = JSON.stringify(agentMessage);\n      const connection = yield this.fetchConnection();\n      yield connection.send(new SpeechConnectionMessage(MessageType.Text, \"agent\", requestId, \"application/json\", agentMessageJson));\n    });\n  }\n\n  privDisconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.NoError, \"Disconnecting\");\n      this.terminateMessageLoop = true;\n      this.agentConfigSent = false;\n      return;\n    });\n  }\n\n  processTypeSpecificMessages(connectionMessage) {\n    const resultProps = new PropertyCollection();\n\n    if (connectionMessage.messageType === MessageType.Text) {\n      resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\n    }\n\n    let result;\n    let processed;\n\n    switch (connectionMessage.path.toLowerCase()) {\n      case \"speech.phrase\":\n        const speechPhrase = SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\n        this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + speechPhrase.Offset + speechPhrase.Duration);\n\n        if (speechPhrase.RecognitionStatus !== RecognitionStatus.TooManyRequests && speechPhrase.RecognitionStatus !== RecognitionStatus.Error) {\n          const args = this.fireEventForResult(speechPhrase, resultProps);\n          this.privLastResult = args.result;\n\n          if (!!this.privDialogServiceConnector.recognized) {\n            try {\n              this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, args);\n              /* eslint-disable no-empty */\n            } catch (error) {// Not going to let errors in the event handler\n              // trip things up.\n            }\n          }\n        }\n\n        processed = true;\n        break;\n\n      case \"speech.hypothesis\":\n        const hypothesis = SpeechHypothesis.fromJSON(connectionMessage.textBody);\n        const offset = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;\n        result = new SpeechRecognitionResult(this.privRequestSession.requestId, ResultReason.RecognizingSpeech, hypothesis.Text, hypothesis.Duration, offset, hypothesis.Language, hypothesis.LanguageDetectionConfidence, undefined, undefined, connectionMessage.textBody, resultProps);\n        this.privRequestSession.onHypothesis(offset);\n        const ev = new SpeechRecognitionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);\n\n        if (!!this.privDialogServiceConnector.recognizing) {\n          try {\n            this.privDialogServiceConnector.recognizing(this.privDialogServiceConnector, ev);\n            /* eslint-disable no-empty */\n          } catch (error) {// Not going to let errors in the event handler\n            // trip things up.\n          }\n        }\n\n        processed = true;\n        break;\n\n      case \"speech.keyword\":\n        const keyword = SpeechKeyword.fromJSON(connectionMessage.textBody);\n        result = new SpeechRecognitionResult(this.privRequestSession.requestId, keyword.Status === \"Accepted\" ? ResultReason.RecognizedKeyword : ResultReason.NoMatch, keyword.Text, keyword.Duration, keyword.Offset, undefined, undefined, undefined, undefined, connectionMessage.textBody, resultProps);\n\n        if (keyword.Status !== \"Accepted\") {\n          this.privLastResult = result;\n        }\n\n        const event = new SpeechRecognitionEventArgs(result, result.duration, result.resultId);\n\n        if (!!this.privDialogServiceConnector.recognized) {\n          try {\n            this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, event);\n            /* eslint-disable no-empty */\n          } catch (error) {// Not going to let errors in the event handler\n            // trip things up.\n          }\n        }\n\n        processed = true;\n        break;\n\n      case \"audio\":\n        {\n          const audioRequestId = connectionMessage.requestId.toUpperCase();\n          const turn = this.privTurnStateManager.GetTurn(audioRequestId);\n\n          try {\n            // Empty binary message signals end of stream.\n            if (!connectionMessage.binaryBody) {\n              turn.endAudioStream();\n            } else {\n              turn.audioStream.write(connectionMessage.binaryBody);\n            }\n          } catch (error) {// Not going to let errors in the event handler\n            // trip things up.\n          }\n        }\n        processed = true;\n        break;\n\n      case \"response\":\n        {\n          this.handleResponseMessage(connectionMessage);\n        }\n        processed = true;\n        break;\n\n      default:\n        break;\n    }\n\n    const defferal = new Deferred();\n    defferal.resolve(processed);\n    return defferal.promise;\n  } // Cancels recognition.\n\n\n  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.terminateMessageLoop = true;\n\n      if (!!this.privRequestSession.isRecognizing) {\n        yield this.privRequestSession.onStopRecognizing();\n      }\n\n      if (!!this.privDialogServiceConnector.canceled) {\n        const properties = new PropertyCollection();\n        properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\n        const cancelEvent = new SpeechRecognitionCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);\n\n        try {\n          this.privDialogServiceConnector.canceled(this.privDialogServiceConnector, cancelEvent);\n          /* eslint-disable no-empty */\n        } catch (_a) {}\n\n        if (!!this.privSuccessCallback) {\n          const result = new SpeechRecognitionResult(undefined, // ResultId\n          ResultReason.Canceled, undefined, // Text\n          undefined, // Duration\n          undefined, // Offset\n          undefined, // Language\n          undefined, // Language Detection Confidence\n          undefined, // Speaker Id\n          error, undefined, // Json\n          properties);\n\n          try {\n            this.privSuccessCallback(result);\n            this.privSuccessCallback = undefined;\n            /* eslint-disable no-empty */\n          } catch (_b) {}\n        }\n      }\n    });\n  }\n\n  listenOnce(recoMode, successCallback, errorCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privRecognizerConfig.recognitionMode = recoMode;\n      this.privSuccessCallback = successCallback;\n      this.privErrorCallback = errorCallback;\n      this.privRequestSession.startNewRecognition();\n      this.privRequestSession.listenForServiceTelemetry(this.privDialogAudioSource.events);\n      this.privRecognizerConfig.parameters.setProperty(PropertyId.Speech_SessionId, this.privRequestSession.sessionId); // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().\n\n      const conPromise = this.connectImpl();\n      const preAudioPromise = this.sendPreAudioMessages();\n      const node = yield this.privDialogAudioSource.attach(this.privRequestSession.audioNodeId);\n      const format = yield this.privDialogAudioSource.format;\n      const deviceInfo = yield this.privDialogAudioSource.deviceInfo;\n      const audioNode = new ReplayableAudioNode(node, format.avgBytesPerSec);\n      yield this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);\n      this.privRecognizerConfig.SpeechServiceConfig.Context.audio = {\n        source: deviceInfo\n      };\n\n      try {\n        yield conPromise;\n        yield preAudioPromise;\n      } catch (error) {\n        yield this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.ConnectionFailure, error);\n        return Promise.resolve();\n      }\n\n      const sessionStartEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\n\n      if (!!this.privRecognizer.sessionStarted) {\n        this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);\n      }\n\n      const audioSendPromise = this.sendAudio(audioNode); // /* eslint-disable no-empty */\n\n      audioSendPromise.then(() => {}, error => __awaiter(this, void 0, void 0, function* () {\n        yield this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\n      }));\n    });\n  } // Establishes a websocket connection to the end point.\n\n\n  dialogConnectImpl(connection) {\n    this.privConnectionLoop = this.startMessageLoop();\n    return connection;\n  }\n\n  receiveDialogMessageOverride() {\n    // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\n    const communicationCustodian = new Deferred();\n\n    const loop = () => __awaiter(this, void 0, void 0, function* () {\n      try {\n        const isDisposed = this.isDisposed();\n        const terminateMessageLoop = !this.isDisposed() && this.terminateMessageLoop;\n\n        if (isDisposed || terminateMessageLoop) {\n          // We're done.\n          communicationCustodian.resolve(undefined);\n          return;\n        }\n\n        const connection = yield this.fetchConnection();\n        const message = yield connection.read();\n\n        if (!message) {\n          return loop();\n        }\n\n        const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\n\n        switch (connectionMessage.path.toLowerCase()) {\n          case \"turn.start\":\n            {\n              const turnRequestId = connectionMessage.requestId.toUpperCase();\n              const audioSessionReqId = this.privRequestSession.requestId.toUpperCase(); // turn started by the service\n\n              if (turnRequestId !== audioSessionReqId) {\n                this.privTurnStateManager.StartTurn(turnRequestId);\n              } else {\n                this.privRequestSession.onServiceTurnStartResponse();\n              }\n            }\n            break;\n\n          case \"speech.startdetected\":\n            const speechStartDetected = SpeechDetected.fromJSON(connectionMessage.textBody);\n            const speechStartEventArgs = new RecognitionEventArgs(speechStartDetected.Offset, this.privRequestSession.sessionId);\n\n            if (!!this.privRecognizer.speechStartDetected) {\n              this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);\n            }\n\n            break;\n\n          case \"speech.enddetected\":\n            let json;\n\n            if (connectionMessage.textBody.length > 0) {\n              json = connectionMessage.textBody;\n            } else {\n              // If the request was empty, the JSON returned is empty.\n              json = \"{ Offset: 0 }\";\n            }\n\n            const speechStopDetected = SpeechDetected.fromJSON(json);\n            this.privRequestSession.onServiceRecognized(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset);\n            const speechStopEventArgs = new RecognitionEventArgs(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);\n\n            if (!!this.privRecognizer.speechEndDetected) {\n              this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);\n            }\n\n            break;\n\n          case \"turn.end\":\n            {\n              const turnEndRequestId = connectionMessage.requestId.toUpperCase();\n              const audioSessionReqId = this.privRequestSession.requestId.toUpperCase(); // turn started by the service\n\n              if (turnEndRequestId !== audioSessionReqId) {\n                this.privTurnStateManager.CompleteTurn(turnEndRequestId);\n              } else {\n                // Audio session turn\n                const sessionStopEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\n                yield this.privRequestSession.onServiceTurnEndResponse(false);\n\n                if (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {\n                  if (!!this.privRecognizer.sessionStopped) {\n                    this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs);\n                  }\n                } // report result to promise.\n\n\n                if (!!this.privSuccessCallback && this.privLastResult) {\n                  try {\n                    this.privSuccessCallback(this.privLastResult);\n                    this.privLastResult = null;\n                  } catch (e) {\n                    if (!!this.privErrorCallback) {\n                      this.privErrorCallback(e);\n                    }\n                  } // Only invoke the call back once.\n                  // and if it's successful don't invoke the\n                  // error after that.\n\n\n                  this.privSuccessCallback = undefined;\n                  this.privErrorCallback = undefined;\n                }\n              }\n            }\n            break;\n\n          default:\n            try {\n              const processed = yield this.processTypeSpecificMessages(connectionMessage);\n\n              if (!processed) {\n                if (!!this.serviceEvents) {\n                  this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\n                }\n              }\n            } catch (e) {//\n            }\n\n        }\n\n        const ret = loop();\n        return ret;\n      } catch (error) {\n        this.terminateMessageLoop = true;\n        communicationCustodian.resolve();\n      }\n    });\n\n    loop().catch(reason => {\n      Events.instance.onEvent(new BackgroundEvent(reason));\n    });\n    return communicationCustodian.promise;\n  }\n\n  startMessageLoop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.terminateMessageLoop = false;\n\n      try {\n        yield this.receiveDialogMessageOverride();\n      } catch (error) {\n        yield this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\n      }\n\n      return Promise.resolve();\n    });\n  } // Takes an established websocket connection to the endpoint and sends speech configuration information.\n\n\n  configConnection(connection) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.terminateMessageLoop) {\n        this.terminateMessageLoop = false;\n        return Promise.reject(\"Connection to service terminated.\");\n      }\n\n      yield this.sendSpeechServiceConfig(connection, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize());\n      yield this.sendAgentConfig(connection);\n      return connection;\n    });\n  }\n\n  sendPreAudioMessages() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.fetchConnection();\n      this.addKeywordContextData();\n      yield this.sendSpeechContext(connection, true);\n      yield this.sendAgentContext(connection);\n      yield this.sendWaveHeader(connection);\n    });\n  }\n\n  sendAgentConfig(connection) {\n    if (this.agentConfig && !this.agentConfigSent) {\n      if (this.privRecognizerConfig.parameters.getProperty(PropertyId.Conversation_DialogType) === DialogServiceConfig.DialogTypes.CustomCommands) {\n        const config = this.agentConfig.get();\n        config.botInfo.commandsCulture = this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage, \"en-us\");\n        this.agentConfig.set(config);\n      }\n\n      this.onEvent(new SendingAgentContextMessageEvent(this.agentConfig));\n      const agentConfigJson = this.agentConfig.toJsonString(); // guard against sending this multiple times on one connection\n\n      this.agentConfigSent = true;\n      return connection.send(new SpeechConnectionMessage(MessageType.Text, \"agent.config\", this.privRequestSession.requestId, \"application/json\", agentConfigJson));\n    }\n\n    return;\n  }\n\n  sendAgentContext(connection) {\n    const guid = createGuid();\n    const speechActivityTemplate = this.privDialogServiceConnector.properties.getProperty(PropertyId.Conversation_Speech_Activity_Template);\n    const agentContext = {\n      channelData: \"\",\n      context: {\n        interactionId: guid\n      },\n      messagePayload: typeof speechActivityTemplate === undefined ? undefined : speechActivityTemplate,\n      version: 0.5\n    };\n    const agentContextJson = JSON.stringify(agentContext);\n    return connection.send(new SpeechConnectionMessage(MessageType.Text, \"speech.agent.context\", this.privRequestSession.requestId, \"application/json\", agentContextJson));\n  }\n\n  fireEventForResult(serviceResult, properties) {\n    const resultReason = EnumTranslation.implTranslateRecognitionResult(serviceResult.RecognitionStatus);\n    const offset = serviceResult.Offset + this.privRequestSession.currentTurnAudioOffset;\n    const result = new SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, serviceResult.DisplayText, serviceResult.Duration, offset, serviceResult.Language, serviceResult.LanguageDetectionConfidence, undefined, undefined, JSON.stringify(serviceResult), properties);\n    const ev = new SpeechRecognitionEventArgs(result, offset, this.privRequestSession.sessionId);\n    return ev;\n  }\n\n  handleResponseMessage(responseMessage) {\n    // \"response\" messages can contain either \"message\" (activity) or \"MessageStatus\" data. Fire the appropriate\n    // event according to the message type that's specified.\n    const responsePayload = JSON.parse(responseMessage.textBody);\n\n    switch (responsePayload.messageType.toLowerCase()) {\n      case \"message\":\n        const responseRequestId = responseMessage.requestId.toUpperCase();\n        const activityPayload = ActivityPayloadResponse.fromJSON(responseMessage.textBody);\n        const turn = this.privTurnStateManager.GetTurn(responseRequestId); // update the conversation Id\n\n        if (activityPayload.conversationId) {\n          const updateAgentConfig = this.agentConfig.get();\n          updateAgentConfig.botInfo.conversationId = activityPayload.conversationId;\n          this.agentConfig.set(updateAgentConfig);\n        }\n\n        const pullAudioOutputStream = turn.processActivityPayload(activityPayload, AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(this.privDialogServiceConnector.properties.getProperty(PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)));\n        const activity = new ActivityReceivedEventArgs(activityPayload.messagePayload, pullAudioOutputStream);\n\n        if (!!this.privDialogServiceConnector.activityReceived) {\n          try {\n            this.privDialogServiceConnector.activityReceived(this.privDialogServiceConnector, activity);\n            /* eslint-disable-next-line no-empty */\n          } catch (error) {// Not going to let errors in the event handler\n            // trip things up.\n          }\n        }\n\n        break;\n\n      case \"messagestatus\":\n        if (!!this.privDialogServiceConnector.turnStatusReceived) {\n          try {\n            this.privDialogServiceConnector.turnStatusReceived(this.privDialogServiceConnector, new TurnStatusReceivedEventArgs(responseMessage.textBody));\n            /* eslint-disable-next-line no-empty */\n          } catch (error) {// Not going to let errors in the event handler\n            // trip things up.\n          }\n        }\n\n        break;\n\n      default:\n        Events.instance.onEvent(new BackgroundEvent(`Unexpected response of type ${responsePayload.messageType}. Ignoring.`));\n        break;\n    }\n  }\n\n  onEvent(event) {\n    this.privEvents.onEvent(event);\n    Events.instance.onEvent(event);\n  }\n\n  addKeywordContextData() {\n    const keywordPropertyValue = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-KeywordsToDetect\");\n\n    if (keywordPropertyValue === undefined) {\n      return;\n    }\n\n    const keywordOffsetPropertyValue = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-KeywordsToDetect-Offsets\");\n    const keywordDurationPropertyValue = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-KeywordsToDetect-Durations\");\n    const keywords = keywordPropertyValue.split(\";\");\n    const keywordOffsets = keywordOffsetPropertyValue === undefined ? [] : keywordOffsetPropertyValue.split(\";\");\n    const keywordDurations = keywordDurationPropertyValue === undefined ? [] : keywordDurationPropertyValue.split(\";\");\n    const keywordDefinitionArray = [];\n\n    for (let i = 0; i < keywords.length; i++) {\n      const definition = {};\n      definition.text = keywords[i];\n\n      if (i < keywordOffsets.length) {\n        definition.offset = Number(keywordOffsets[i]);\n      }\n\n      if (i < keywordDurations.length) {\n        definition.duration = Number(keywordDurations[i]);\n      }\n\n      keywordDefinitionArray.push(definition);\n    }\n\n    this.speechContext.setSection(\"invocationSource\", \"VoiceActivationWithKeyword\");\n    this.speechContext.setSection(\"keywordDetection\", [{\n      clientDetectedKeywords: keywordDefinitionArray,\n      onReject: {\n        action: \"EndOfTurn\"\n      },\n      type: \"startTrigger\"\n    }]);\n  }\n\n} //# sourceMappingURL=DialogServiceAdapter.js.map","map":null,"metadata":{},"sourceType":"module"}