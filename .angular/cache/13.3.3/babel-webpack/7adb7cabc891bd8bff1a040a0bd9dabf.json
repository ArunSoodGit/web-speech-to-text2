{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { marshalPromiseToCallbacks } from \"../../common/Exports\";\nimport { Contracts } from \"../../sdk/Contracts\";\nimport { PropertyId, Recognizer } from \"../../sdk/Exports\";\nimport { RecognitionMode, RecognizerConfig, TranscriberConnectionFactory, TranscriptionServiceRecognizer } from \"../Exports\";\nexport class TranscriberRecognizer extends Recognizer {\n  /**\n   * TranscriberRecognizer constructor.\n   * @constructor\n   * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer\n   */\n  constructor(speechTranslationConfig, audioConfig) {\n    const speechTranslationConfigImpl = speechTranslationConfig;\n    Contracts.throwIfNull(speechTranslationConfigImpl, \"speechTranslationConfig\");\n    Contracts.throwIfNullOrWhitespace(speechTranslationConfigImpl.speechRecognitionLanguage, PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage]);\n    super(audioConfig, speechTranslationConfigImpl.properties, new TranscriberConnectionFactory());\n    this.privDisposedRecognizer = false;\n  }\n\n  get speechRecognitionLanguage() {\n    Contracts.throwIfDisposed(this.privDisposedRecognizer);\n    return this.properties.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage);\n  }\n\n  get properties() {\n    return this.privProperties;\n  }\n\n  get authorizationToken() {\n    return this.properties.getProperty(PropertyId.SpeechServiceAuthorization_Token);\n  }\n\n  set authorizationToken(token) {\n    Contracts.throwIfNullOrWhitespace(token, \"token\");\n    this.properties.setProperty(PropertyId.SpeechServiceAuthorization_Token, token);\n  }\n\n  set conversation(c) {\n    Contracts.throwIfNullOrUndefined(c, \"Conversation\");\n    this.privConversation = c;\n  }\n\n  getConversationInfo() {\n    Contracts.throwIfNullOrUndefined(this.privConversation, \"Conversation\");\n    return this.privConversation.conversationInfo;\n  }\n\n  startContinuousRecognitionAsync(cb, err) {\n    marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(RecognitionMode.Conversation), cb, err);\n  }\n\n  stopContinuousRecognitionAsync(cb, err) {\n    marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), cb, err);\n  }\n\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.privDisposedRecognizer) {\n        yield this.dispose(true);\n      }\n    });\n  } // Push async join/leave conversation message via serviceRecognizer\n\n\n  pushConversationEvent(conversationInfo, command) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const reco = this.privReco;\n      Contracts.throwIfNullOrUndefined(reco, \"serviceRecognizer\");\n      yield reco.sendSpeechEventAsync(conversationInfo, command);\n    });\n  }\n\n  connectCallbacks(transcriber) {\n    this.canceled = (s, e) => {\n      if (!!transcriber.canceled) {\n        transcriber.canceled(transcriber, e);\n      }\n    };\n\n    this.conversationCanceled = (s, e) => {\n      if (!!transcriber.conversationCanceled) {\n        transcriber.conversationCanceled(transcriber, e);\n      }\n    };\n\n    this.recognizing = (s, e) => {\n      if (!!transcriber.transcribing) {\n        transcriber.transcribing(transcriber, e);\n      }\n    };\n\n    this.recognized = (s, e) => {\n      if (!!transcriber.transcribed) {\n        transcriber.transcribed(transcriber, e);\n      }\n    };\n\n    this.conversationStarted = (s, e) => {\n      if (!!transcriber.conversationStarted) {\n        transcriber.conversationStarted(transcriber, e);\n      }\n    };\n\n    this.conversationStopped = (s, e) => {\n      if (!!transcriber.conversationStopped) {\n        transcriber.conversationStopped(transcriber, e);\n      }\n    };\n\n    this.sessionStarted = (s, e) => {\n      if (!!transcriber.sessionStarted) {\n        transcriber.sessionStarted(transcriber, e);\n      }\n    };\n\n    this.sessionStopped = (s, e) => {\n      if (!!transcriber.sessionStopped) {\n        transcriber.sessionStopped(transcriber, e);\n      }\n    };\n  }\n\n  disconnectCallbacks() {\n    this.canceled = undefined;\n    this.recognizing = undefined;\n    this.recognized = undefined;\n    this.sessionStarted = undefined;\n    this.sessionStopped = undefined;\n    this.conversationCanceled = undefined;\n    this.conversationStarted = undefined;\n    this.conversationStopped = undefined;\n  }\n  /**\n   * Disposes any resources held by the object.\n   * @member ConversationTranscriber.prototype.dispose\n   * @function\n   * @public\n   * @param {boolean} disposing - true if disposing the object.\n   */\n\n\n  dispose(disposing) {\n    const _super = Object.create(null, {\n      dispose: {\n        get: () => super.dispose\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.privDisposedRecognizer) {\n        return;\n      }\n\n      if (disposing) {\n        this.privDisposedRecognizer = true;\n        yield this.implRecognizerStop();\n      }\n\n      yield _super.dispose.call(this, disposing);\n    });\n  }\n\n  createRecognizerConfig(speechConfig) {\n    return new RecognizerConfig(speechConfig, this.properties);\n  }\n\n  createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {\n    const configImpl = audioConfig;\n    return new TranscriptionServiceRecognizer(authentication, connectionFactory, configImpl, recognizerConfig, this);\n  }\n\n} //# sourceMappingURL=TranscriberRecognizer.js.map","map":null,"metadata":{},"sourceType":"module"}