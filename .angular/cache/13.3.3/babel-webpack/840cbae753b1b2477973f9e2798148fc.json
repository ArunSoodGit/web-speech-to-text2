{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { AutoDetectSourceLanguagesOpenRangeOptionName } from \"../common.speech/Exports\";\nimport { Contracts } from \"./Contracts\";\nimport { PropertyCollection, PropertyId } from \"./Exports\";\nimport { LanguageIdMode } from \"./LanguageIdMode\";\nimport { LanguageIdPriority } from \"./LanguageIdPriority\";\n/**\n * Language auto detect configuration.\n * @class AutoDetectSourceLanguageConfig\n * Added in version 1.13.0.\n */\n\nexport class AutoDetectSourceLanguageConfig {\n  constructor() {\n    this.privProperties = new PropertyCollection();\n    this.privProperties.setProperty(PropertyId.SpeechServiceConnection_AtStartLanguageIdPriority, \"Latency\");\n    this.privLanguageIdMode = LanguageIdMode.AtStart;\n  }\n  /**\n   * @member AutoDetectSourceLanguageConfig.fromOpenRange\n   * @function\n   * @public\n   * Only [[SpeechSynthesizer]] supports source language auto detection from open range,\n   * for [[Recognizer]], please use AutoDetectSourceLanguageConfig with specific source languages.\n   * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig\n   * @summary Creates an instance of the AutoDetectSourceLanguageConfig with open range.\n   */\n\n\n  static fromOpenRange() {\n    const config = new AutoDetectSourceLanguageConfig();\n    config.properties.setProperty(PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, AutoDetectSourceLanguagesOpenRangeOptionName);\n    return config;\n  }\n  /**\n   * @member AutoDetectSourceLanguageConfig.fromLanguages\n   * @function\n   * @public\n   * @param {string[]} languages Comma-separated string of languages (eg. \"en-US,fr-FR\") to populate properties of config.\n   * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig\n   * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given languages.\n   */\n\n\n  static fromLanguages(languages) {\n    Contracts.throwIfArrayEmptyOrWhitespace(languages, \"languages\");\n    const config = new AutoDetectSourceLanguageConfig();\n    config.properties.setProperty(PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, languages.join());\n    return config;\n  }\n  /**\n   * @member AutoDetectSourceLanguageConfig.fromSourceLanguageConfigs\n   * @function\n   * @public\n   * @param {SourceLanguageConfig[]} configs SourceLanguageConfigs to populate properties of config.\n   * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig\n   * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given SourceLanguageConfigs.\n   */\n\n\n  static fromSourceLanguageConfigs(configs) {\n    if (configs.length < 1) {\n      throw new Error(\"Expected non-empty SourceLanguageConfig array.\");\n    }\n\n    const autoConfig = new AutoDetectSourceLanguageConfig();\n    const langs = [];\n    configs.forEach(config => {\n      langs.push(config.language);\n\n      if (config.endpointId !== undefined && config.endpointId !== \"\") {\n        const customProperty = config.language + PropertyId.SpeechServiceConnection_EndpointId.toString();\n        autoConfig.properties.setProperty(customProperty, config.endpointId);\n      }\n    });\n    autoConfig.properties.setProperty(PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, langs.join());\n    return autoConfig;\n  }\n  /**\n   * @member AutoDetectSourceLanguageConfig.prototype.properties\n   * @function\n   * @public\n   * @return {PropertyCollection} Properties of the config.\n   * @summary Gets an auto detected language config properties\n   */\n\n\n  get properties() {\n    return this.privProperties;\n  }\n  /**\n   * @member AutoDetectSourceLanguageConfig.prototype.mode\n   * @function\n   * @public\n   * @param {LanguageIdMode} mode LID mode desired.\n   * @summary Sets LID operation to desired mode\n   */\n\n\n  set mode(mode) {\n    if (mode === LanguageIdMode.Continuous) {\n      this.privProperties.setProperty(PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, \"2\");\n      this.privProperties.setProperty(PropertyId.SpeechServiceConnection_ContinuousLanguageIdPriority, \"Latency\");\n    } else {\n      this.privProperties.setProperty(PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, \"1\");\n      this.privProperties.setProperty(PropertyId.SpeechServiceConnection_ContinuousLanguageIdPriority, undefined);\n    }\n\n    this.privLanguageIdMode = mode;\n  }\n  /**\n   * @member AutoDetectSourceLanguageConfig.prototype.priority\n   * @function\n   * @public\n   * @param {LanguageIdPriority} priority LID priority desired.\n   * @summary Sets LID operation to desired priority\n   */\n\n\n  set priority(priority) {\n    if (priority === LanguageIdPriority.Accuracy) {\n      if (this.privLanguageIdMode !== LanguageIdMode.Continuous) {\n        // Accuracy not allowed for continuous mode\n        this.privProperties.setProperty(PropertyId.SpeechServiceConnection_AtStartLanguageIdPriority, \"Accuracy\");\n      }\n    } else {\n      this.privProperties.setProperty(PropertyId.SpeechServiceConnection_ContinuousLanguageIdPriority, \"Latency\");\n      this.privProperties.setProperty(PropertyId.SpeechServiceConnection_AtStartLanguageIdPriority, \"Latency\");\n    }\n  }\n\n} //# sourceMappingURL=AutoDetectSourceLanguageConfig.js.map","map":null,"metadata":{},"sourceType":"module"}