{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\n/* eslint-disable max-classes-per-file */\nimport { ForceDictationPropertyName, OutputFormatPropertyName, ServicePropertiesPropertyName } from \"../common.speech/Exports\";\nimport { Contracts } from \"./Contracts\";\nimport { OutputFormat, ProfanityOption, PropertyCollection, PropertyId, SpeechSynthesisOutputFormat } from \"./Exports\";\n/**\n * Speech configuration.\n * @class SpeechConfig\n */\n\nexport class SpeechConfig {\n  /**\n   * Creates and initializes an instance.\n   * @constructor\n   */\n  constructor() {\n    return;\n  }\n  /**\n   * Static instance of SpeechConfig returned by passing subscriptionKey and service region.\n   * Note: Please use your LanguageUnderstanding subscription key in case you want to use the Intent recognizer.\n   * @member SpeechConfig.fromSubscription\n   * @function\n   * @public\n   * @param {string} subscriptionKey - The subscription key.\n   * @param {string} region - The region name (see the <a href=\"https://aka.ms/csspeech/region\">region page</a>).\n   * @returns {SpeechConfig} The speech factory\n   */\n\n\n  static fromSubscription(subscriptionKey, region) {\n    Contracts.throwIfNullOrWhitespace(subscriptionKey, \"subscriptionKey\");\n    Contracts.throwIfNullOrWhitespace(region, \"region\");\n    const speechImpl = new SpeechConfigImpl();\n    speechImpl.setProperty(PropertyId.SpeechServiceConnection_Region, region);\n    speechImpl.setProperty(PropertyId.SpeechServiceConnection_IntentRegion, region);\n    speechImpl.setProperty(PropertyId.SpeechServiceConnection_Key, subscriptionKey);\n    return speechImpl;\n  }\n  /**\n   * Creates an instance of the speech config with specified endpoint and subscription key.\n   * This method is intended only for users who use a non-standard service endpoint or parameters.\n   * Note: Please use your LanguageUnderstanding subscription key in case you want to use the Intent recognizer.\n   * Note: The query parameters specified in the endpoint URL are not changed, even if they are set by any other APIs.\n   * For example, if language is defined in the uri as query parameter \"language=de-DE\", and also set by\n   * SpeechConfig.speechRecognitionLanguage = \"en-US\", the language setting in uri takes precedence,\n   * and the effective language is \"de-DE\". Only the parameters that are not specified in the\n   * endpoint URL can be set by other APIs.\n   * Note: To use authorization token with fromEndpoint, pass an empty string to the subscriptionKey in the\n   * fromEndpoint method, and then set authorizationToken=\"token\" on the created SpeechConfig instance to\n   * use the authorization token.\n   * @member SpeechConfig.fromEndpoint\n   * @function\n   * @public\n   * @param {URL} endpoint - The service endpoint to connect to.\n   * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.\n   * @returns {SpeechConfig} A speech factory instance.\n   */\n\n\n  static fromEndpoint(endpoint, subscriptionKey) {\n    Contracts.throwIfNull(endpoint, \"endpoint\");\n    const speechImpl = new SpeechConfigImpl();\n    speechImpl.setProperty(PropertyId.SpeechServiceConnection_Endpoint, endpoint.href);\n\n    if (undefined !== subscriptionKey) {\n      speechImpl.setProperty(PropertyId.SpeechServiceConnection_Key, subscriptionKey);\n    }\n\n    return speechImpl;\n  }\n  /**\n   * Creates an instance of the speech config with specified host and subscription key.\n   * This method is intended only for users who use a non-default service host. Standard resource path will be assumed.\n   * For services with a non-standard resource path or no path at all, use fromEndpoint instead.\n   * Note: Query parameters are not allowed in the host URI and must be set by other APIs.\n   * Note: To use an authorization token with fromHost, use fromHost(URL),\n   * and then set the AuthorizationToken property on the created SpeechConfig instance.\n   * Note: Added in version 1.9.0.\n   * @member SpeechConfig.fromHost\n   * @function\n   * @public\n   * @param {URL} host - The service endpoint to connect to. Format is \"protocol://host:port\" where \":port\" is optional.\n   * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.\n   * @returns {SpeechConfig} A speech factory instance.\n   */\n\n\n  static fromHost(hostName, subscriptionKey) {\n    Contracts.throwIfNull(hostName, \"hostName\");\n    const speechImpl = new SpeechConfigImpl();\n    speechImpl.setProperty(PropertyId.SpeechServiceConnection_Host, hostName.protocol + \"//\" + hostName.hostname + (hostName.port === \"\" ? \"\" : \":\" + hostName.port));\n\n    if (undefined !== subscriptionKey) {\n      speechImpl.setProperty(PropertyId.SpeechServiceConnection_Key, subscriptionKey);\n    }\n\n    return speechImpl;\n  }\n  /**\n   * Creates an instance of the speech factory with specified initial authorization token and region.\n   * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token\n   * expires, the caller needs to refresh it by calling this setter with a new valid token.\n   * Note: Please use a token derived from your LanguageUnderstanding subscription key in case you want\n   * to use the Intent recognizer. As configuration values are copied when creating a new recognizer,\n   * the new token value will not apply to recognizers that have already been created. For recognizers\n   * that have been created before, you need to set authorization token of the corresponding recognizer\n   * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.\n   * @member SpeechConfig.fromAuthorizationToken\n   * @function\n   * @public\n   * @param {string} authorizationToken - The initial authorization token.\n   * @param {string} region - The region name (see the <a href=\"https://aka.ms/csspeech/region\">region page</a>).\n   * @returns {SpeechConfig} A speech factory instance.\n   */\n\n\n  static fromAuthorizationToken(authorizationToken, region) {\n    Contracts.throwIfNull(authorizationToken, \"authorizationToken\");\n    Contracts.throwIfNullOrWhitespace(region, \"region\");\n    const speechImpl = new SpeechConfigImpl();\n    speechImpl.setProperty(PropertyId.SpeechServiceConnection_Region, region);\n    speechImpl.setProperty(PropertyId.SpeechServiceConnection_IntentRegion, region);\n    speechImpl.authorizationToken = authorizationToken;\n    return speechImpl;\n  }\n  /**\n   * Closes the configuration.\n   * @member SpeechConfig.prototype.close\n   * @function\n   * @public\n   */\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\n  close() {}\n\n}\n/**\n * @public\n * @class SpeechConfigImpl\n */\n\nexport class SpeechConfigImpl extends SpeechConfig {\n  constructor() {\n    super();\n    this.privProperties = new PropertyCollection();\n    this.speechRecognitionLanguage = \"en-US\"; // Should we have a default?\n\n    this.outputFormat = OutputFormat.Simple;\n  }\n\n  get properties() {\n    return this.privProperties;\n  }\n\n  get endPoint() {\n    return new URL(this.privProperties.getProperty(PropertyId.SpeechServiceConnection_Endpoint));\n  }\n\n  get subscriptionKey() {\n    return this.privProperties.getProperty(PropertyId.SpeechServiceConnection_Key);\n  }\n\n  get region() {\n    return this.privProperties.getProperty(PropertyId.SpeechServiceConnection_Region);\n  }\n\n  get authorizationToken() {\n    return this.privProperties.getProperty(PropertyId.SpeechServiceAuthorization_Token);\n  }\n\n  set authorizationToken(value) {\n    this.privProperties.setProperty(PropertyId.SpeechServiceAuthorization_Token, value);\n  }\n\n  get speechRecognitionLanguage() {\n    return this.privProperties.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage);\n  }\n\n  set speechRecognitionLanguage(value) {\n    this.privProperties.setProperty(PropertyId.SpeechServiceConnection_RecoLanguage, value);\n  }\n\n  get autoDetectSourceLanguages() {\n    return this.privProperties.getProperty(PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages);\n  }\n\n  set autoDetectSourceLanguages(value) {\n    this.privProperties.setProperty(PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, value);\n  }\n\n  get outputFormat() {\n    return OutputFormat[this.privProperties.getProperty(OutputFormatPropertyName, undefined)];\n  }\n\n  set outputFormat(value) {\n    this.privProperties.setProperty(OutputFormatPropertyName, OutputFormat[value]);\n  }\n\n  get endpointId() {\n    return this.privProperties.getProperty(PropertyId.SpeechServiceConnection_EndpointId);\n  }\n\n  set endpointId(value) {\n    this.privProperties.setProperty(PropertyId.SpeechServiceConnection_EndpointId, value);\n  }\n\n  setProperty(name, value) {\n    Contracts.throwIfNull(value, \"value\");\n    this.privProperties.setProperty(name, value);\n  }\n\n  getProperty(name, def) {\n    return this.privProperties.getProperty(name, def);\n  }\n\n  setProxy(proxyHostName, proxyPort, proxyUserName, proxyPassword) {\n    this.setProperty(PropertyId[PropertyId.SpeechServiceConnection_ProxyHostName], proxyHostName);\n    this.setProperty(PropertyId[PropertyId.SpeechServiceConnection_ProxyPort], proxyPort);\n    this.setProperty(PropertyId[PropertyId.SpeechServiceConnection_ProxyUserName], proxyUserName);\n    this.setProperty(PropertyId[PropertyId.SpeechServiceConnection_ProxyPassword], proxyPassword);\n  }\n\n  setServiceProperty(name, value) {\n    const currentProperties = JSON.parse(this.privProperties.getProperty(ServicePropertiesPropertyName, \"{}\"));\n    currentProperties[name] = value;\n    this.privProperties.setProperty(ServicePropertiesPropertyName, JSON.stringify(currentProperties));\n  }\n\n  setProfanity(profanity) {\n    this.privProperties.setProperty(PropertyId.SpeechServiceResponse_ProfanityOption, ProfanityOption[profanity]);\n  }\n\n  enableAudioLogging() {\n    this.privProperties.setProperty(PropertyId.SpeechServiceConnection_EnableAudioLogging, \"true\");\n  }\n\n  requestWordLevelTimestamps() {\n    this.privProperties.setProperty(PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, \"true\");\n  }\n\n  enableDictation() {\n    this.privProperties.setProperty(ForceDictationPropertyName, \"true\");\n  }\n\n  clone() {\n    const ret = new SpeechConfigImpl();\n    ret.privProperties = this.privProperties.clone();\n    return ret;\n  }\n\n  get speechSynthesisLanguage() {\n    return this.privProperties.getProperty(PropertyId.SpeechServiceConnection_SynthLanguage);\n  }\n\n  set speechSynthesisLanguage(language) {\n    this.privProperties.setProperty(PropertyId.SpeechServiceConnection_SynthLanguage, language);\n  }\n\n  get speechSynthesisVoiceName() {\n    return this.privProperties.getProperty(PropertyId.SpeechServiceConnection_SynthVoice);\n  }\n\n  set speechSynthesisVoiceName(voice) {\n    this.privProperties.setProperty(PropertyId.SpeechServiceConnection_SynthVoice, voice);\n  }\n\n  get speechSynthesisOutputFormat() {\n    return SpeechSynthesisOutputFormat[this.privProperties.getProperty(PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)];\n  }\n\n  set speechSynthesisOutputFormat(format) {\n    this.privProperties.setProperty(PropertyId.SpeechServiceConnection_SynthOutputFormat, SpeechSynthesisOutputFormat[format]);\n  }\n\n} //# sourceMappingURL=SpeechConfig.js.map","map":null,"metadata":{},"sourceType":"module"}