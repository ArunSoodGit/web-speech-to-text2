{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ReplayableAudioNode } from \"../common.browser/Exports\";\nimport { ArgumentNullError, ConnectionState, createNoDashGuid, EventSource, MessageType, ServiceEvent, Timeout } from \"../common/Exports\";\nimport { CancellationErrorCode, CancellationReason, PropertyId, RecognitionEventArgs, SessionEventArgs } from \"../sdk/Exports\";\nimport { AgentConfig, DynamicGrammarBuilder, RequestSession, SpeechContext, SpeechDetected, type } from \"./Exports\";\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\nexport let ServiceRecognizerBase = /*#__PURE__*/(() => {\n  class ServiceRecognizerBase {\n    constructor(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {\n      // A promise for a configured connection.\n      // Do not consume directly, call fetchConnection instead.\n      this.privConnectionConfigurationPromise = undefined; // A promise for a connection, but one that has not had the speech context sent yet.\n      // Do not consume directly, call fetchConnection instead.\n\n      this.privConnectionPromise = undefined;\n      this.privSetTimeout = setTimeout;\n      this.privIsLiveAudio = false;\n      this.recognizeOverride = undefined;\n      this.disconnectOverride = undefined;\n      this.receiveMessageOverride = undefined;\n      this.sendPrePayloadJSONOverride = undefined;\n      this.postConnectImplOverride = undefined;\n      this.configConnectionOverride = undefined;\n\n      if (!authentication) {\n        throw new ArgumentNullError(\"authentication\");\n      }\n\n      if (!connectionFactory) {\n        throw new ArgumentNullError(\"connectionFactory\");\n      }\n\n      if (!audioSource) {\n        throw new ArgumentNullError(\"audioSource\");\n      }\n\n      if (!recognizerConfig) {\n        throw new ArgumentNullError(\"recognizerConfig\");\n      }\n\n      this.privMustReportEndOfStream = false;\n      this.privAuthentication = authentication;\n      this.privConnectionFactory = connectionFactory;\n      this.privAudioSource = audioSource;\n      this.privRecognizerConfig = recognizerConfig;\n      this.privIsDisposed = false;\n      this.privRecognizer = recognizer;\n      this.privRequestSession = new RequestSession(this.privAudioSource.id());\n      this.privConnectionEvents = new EventSource();\n      this.privServiceEvents = new EventSource();\n      this.privDynamicGrammar = new DynamicGrammarBuilder();\n      this.privSpeechContext = new SpeechContext(this.privDynamicGrammar);\n      this.privAgentConfig = new AgentConfig();\n\n      if (typeof Blob !== \"undefined\" && typeof Worker !== \"undefined\") {\n        this.privSetTimeout = Timeout.setTimeout;\n      }\n\n      this.connectionEvents.attach(connectionEvent => {\n        if (connectionEvent.name === \"ConnectionClosedEvent\") {\n          const connectionClosedEvent = connectionEvent;\n\n          if (connectionClosedEvent.statusCode === 1003 || connectionClosedEvent.statusCode === 1007 || connectionClosedEvent.statusCode === 1002 || connectionClosedEvent.statusCode === 4000 || this.privRequestSession.numConnectionAttempts > this.privRecognizerConfig.maxRetryCount) {\n            void this.cancelRecognitionLocal(CancellationReason.Error, connectionClosedEvent.statusCode === 1007 ? CancellationErrorCode.BadRequestParameters : CancellationErrorCode.ConnectionFailure, `${connectionClosedEvent.reason} websocket error code: ${connectionClosedEvent.statusCode}`);\n          }\n        }\n      });\n    }\n\n    get audioSource() {\n      return this.privAudioSource;\n    }\n\n    get speechContext() {\n      return this.privSpeechContext;\n    }\n\n    get dynamicGrammar() {\n      return this.privDynamicGrammar;\n    }\n\n    get agentConfig() {\n      return this.privAgentConfig;\n    }\n\n    set conversationTranslatorToken(token) {\n      this.privRecognizerConfig.parameters.setProperty(PropertyId.ConversationTranslator_Token, token);\n    }\n\n    set authentication(auth) {\n      this.privAuthentication = this.authentication;\n    }\n\n    isDisposed() {\n      return this.privIsDisposed;\n    }\n\n    dispose(reason) {\n      return __awaiter(this, void 0, void 0, function* () {\n        this.privIsDisposed = true;\n\n        if (this.privConnectionConfigurationPromise !== undefined) {\n          try {\n            const connection = yield this.privConnectionConfigurationPromise;\n            yield connection.dispose(reason);\n          } catch (error) {\n            // The connection is in a bad state. But we're trying to kill it, so...\n            return;\n          }\n        }\n      });\n    }\n\n    get connectionEvents() {\n      return this.privConnectionEvents;\n    }\n\n    get serviceEvents() {\n      return this.privServiceEvents;\n    }\n\n    get recognitionMode() {\n      return this.privRecognizerConfig.recognitionMode;\n    }\n\n    recognize(recoMode, successCallback, errorCallBack) {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (this.recognizeOverride !== undefined) {\n          yield this.recognizeOverride(recoMode, successCallback, errorCallBack);\n          return;\n        } // Clear the existing configuration promise to force a re-transmission of config and context.\n\n\n        this.privConnectionConfigurationPromise = undefined;\n        this.privRecognizerConfig.recognitionMode = recoMode;\n        this.privSuccessCallback = successCallback;\n        this.privErrorCallback = errorCallBack;\n        this.privRequestSession.startNewRecognition();\n        this.privRequestSession.listenForServiceTelemetry(this.privAudioSource.events); // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().\n\n        const conPromise = this.connectImpl();\n        let audioNode;\n\n        try {\n          const audioStreamNode = yield this.audioSource.attach(this.privRequestSession.audioNodeId);\n          const format = yield this.audioSource.format;\n          const deviceInfo = yield this.audioSource.deviceInfo;\n          this.privIsLiveAudio = deviceInfo.type && deviceInfo.type === type.Microphones;\n          audioNode = new ReplayableAudioNode(audioStreamNode, format.avgBytesPerSec);\n          yield this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);\n          this.privRecognizerConfig.SpeechServiceConfig.Context.audio = {\n            source: deviceInfo\n          };\n        } catch (error) {\n          yield this.privRequestSession.onStopRecognizing();\n          throw error;\n        }\n\n        try {\n          yield conPromise;\n        } catch (error) {\n          yield this.cancelRecognitionLocal(CancellationReason.Error, CancellationErrorCode.ConnectionFailure, error);\n          return;\n        }\n\n        const sessionStartEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\n\n        if (!!this.privRecognizer.sessionStarted) {\n          this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);\n        }\n\n        void this.receiveMessage();\n        const audioSendPromise = this.sendAudio(audioNode);\n        audioSendPromise.catch(error => __awaiter(this, void 0, void 0, function* () {\n          yield this.cancelRecognitionLocal(CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\n        }));\n        return;\n      });\n    }\n\n    stopRecognizing() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (this.privRequestSession.isRecognizing) {\n          try {\n            yield this.audioSource.turnOff();\n            yield this.sendFinalAudio();\n            yield this.privRequestSession.onStopRecognizing();\n            yield this.privRequestSession.turnCompletionPromise;\n          } finally {\n            yield this.privRequestSession.dispose();\n          }\n        }\n\n        return;\n      });\n    }\n\n    connect() {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield this.connectImpl();\n        return Promise.resolve();\n      });\n    }\n\n    connectAsync(cb, err) {\n      this.connectImpl().then(() => {\n        try {\n          if (!!cb) {\n            cb();\n          }\n        } catch (e) {\n          if (!!err) {\n            err(e);\n          }\n        }\n      }, reason => {\n        try {\n          if (!!err) {\n            err(reason);\n          }\n          /* eslint-disable no-empty */\n\n        } catch (error) {}\n      });\n    }\n\n    disconnect() {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield this.cancelRecognitionLocal(CancellationReason.Error, CancellationErrorCode.NoError, \"Disconnecting\");\n\n        if (this.disconnectOverride !== undefined) {\n          yield this.disconnectOverride();\n        }\n\n        if (this.privConnectionPromise !== undefined) {\n          try {\n            yield (yield this.privConnectionPromise).dispose();\n          } catch (error) {}\n        }\n\n        this.privConnectionPromise = undefined;\n      });\n    } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    sendMessage(message) {\n      return;\n    }\n\n    sendNetworkMessage(path, payload) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const type = typeof payload === \"string\" ? MessageType.Text : MessageType.Binary;\n        const contentType = typeof payload === \"string\" ? \"application/json\" : \"\";\n        const connection = yield this.fetchConnection();\n        return connection.send(new SpeechConnectionMessage(type, path, this.privRequestSession.requestId, contentType, payload));\n      });\n    }\n\n    set activityTemplate(messagePayload) {\n      this.privActivityTemplate = messagePayload;\n    }\n\n    get activityTemplate() {\n      return this.privActivityTemplate;\n    }\n\n    sendTelemetryData() {\n      return __awaiter(this, void 0, void 0, function* () {\n        const telemetryData = this.privRequestSession.getTelemetry();\n\n        if (ServiceRecognizerBase.telemetryDataEnabled !== true || this.privIsDisposed || null === telemetryData) {\n          return;\n        }\n\n        if (!!ServiceRecognizerBase.telemetryData) {\n          try {\n            ServiceRecognizerBase.telemetryData(telemetryData);\n            /* eslint-disable no-empty */\n          } catch (_a) {}\n        }\n\n        const connection = yield this.fetchConnection();\n        yield connection.send(new SpeechConnectionMessage(MessageType.Text, \"telemetry\", this.privRequestSession.requestId, \"application/json\", telemetryData));\n      });\n    } // Cancels recognition.\n\n\n    cancelRecognitionLocal(cancellationReason, errorCode, error) {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (!!this.privRequestSession.isRecognizing) {\n          yield this.privRequestSession.onStopRecognizing();\n          this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, cancellationReason, errorCode, error);\n        }\n      });\n    }\n\n    receiveMessage() {\n      return __awaiter(this, void 0, void 0, function* () {\n        try {\n          if (this.privIsDisposed) {\n            // We're done.\n            return;\n          }\n\n          let connection = yield this.fetchConnection();\n          const message = yield connection.read();\n\n          if (this.receiveMessageOverride !== undefined) {\n            return this.receiveMessageOverride();\n          } // indicates we are draining the queue and it came with no message;\n\n\n          if (!message) {\n            if (!this.privRequestSession.isRecognizing) {\n              return;\n            } else {\n              return this.receiveMessage();\n            }\n          }\n\n          this.privServiceHasSentMessage = true;\n          const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\n\n          if (connectionMessage.requestId.toLowerCase() === this.privRequestSession.requestId.toLowerCase()) {\n            switch (connectionMessage.path.toLowerCase()) {\n              case \"turn.start\":\n                this.privMustReportEndOfStream = true;\n                this.privRequestSession.onServiceTurnStartResponse();\n                break;\n\n              case \"speech.startdetected\":\n                const speechStartDetected = SpeechDetected.fromJSON(connectionMessage.textBody);\n                const speechStartEventArgs = new RecognitionEventArgs(speechStartDetected.Offset, this.privRequestSession.sessionId);\n\n                if (!!this.privRecognizer.speechStartDetected) {\n                  this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);\n                }\n\n                break;\n\n              case \"speech.enddetected\":\n                let json;\n\n                if (connectionMessage.textBody.length > 0) {\n                  json = connectionMessage.textBody;\n                } else {\n                  // If the request was empty, the JSON returned is empty.\n                  json = \"{ Offset: 0 }\";\n                }\n\n                const speechStopDetected = SpeechDetected.fromJSON(json); // Only shrink the buffers for continuous recognition.\n                // For single shot, the speech.phrase message will come after the speech.end and it should own buffer shrink.\n\n                if (this.privRecognizerConfig.isContinuousRecognition) {\n                  this.privRequestSession.onServiceRecognized(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset);\n                }\n\n                const speechStopEventArgs = new RecognitionEventArgs(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);\n\n                if (!!this.privRecognizer.speechEndDetected) {\n                  this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);\n                }\n\n                break;\n\n              case \"turn.end\":\n                yield this.sendTelemetryData();\n\n                if (this.privRequestSession.isSpeechEnded && this.privMustReportEndOfStream) {\n                  this.privMustReportEndOfStream = false;\n                  yield this.cancelRecognitionLocal(CancellationReason.EndOfStream, CancellationErrorCode.NoError, undefined);\n                }\n\n                const sessionStopEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\n                yield this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition);\n\n                if (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {\n                  if (!!this.privRecognizer.sessionStopped) {\n                    this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs);\n                  }\n\n                  return;\n                } else {\n                  connection = yield this.fetchConnection();\n                  yield this.sendPrePayloadJSON(connection);\n                }\n\n                break;\n\n              default:\n                if (!(yield this.processTypeSpecificMessages(connectionMessage))) {\n                  // here are some messages that the derived class has not processed, dispatch them to connect class\n                  if (!!this.privServiceEvents) {\n                    this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\n                  }\n                }\n\n            }\n          }\n\n          return this.receiveMessage();\n        } catch (error) {\n          return null;\n        }\n      });\n    }\n\n    sendSpeechContext(connection, generateNewRequestId) {\n      const speechContextJson = this.speechContext.toJSON();\n\n      if (generateNewRequestId) {\n        this.privRequestSession.onSpeechContext();\n      }\n\n      if (speechContextJson) {\n        return connection.send(new SpeechConnectionMessage(MessageType.Text, \"speech.context\", this.privRequestSession.requestId, \"application/json\", speechContextJson));\n      }\n\n      return;\n    } // Encapsulated for derived service recognizers that need to send additional JSON\n\n\n    sendPrePayloadJSON(connection, generateNewRequestId = true) {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (this.sendPrePayloadJSONOverride !== undefined) {\n          return this.sendPrePayloadJSONOverride(connection);\n        }\n\n        yield this.sendSpeechContext(connection, generateNewRequestId);\n        yield this.sendWaveHeader(connection);\n        return;\n      });\n    }\n\n    sendWaveHeader(connection) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const format = yield this.audioSource.format; // this.writeBufferToConsole(format.header);\n\n        return connection.send(new SpeechConnectionMessage(MessageType.Binary, \"audio\", this.privRequestSession.requestId, \"audio/x-wav\", format.header));\n      });\n    } // Establishes a websocket connection to the end point.\n\n\n    connectImpl() {\n      if (this.privConnectionPromise !== undefined) {\n        return this.privConnectionPromise.then(connection => {\n          if (connection.state() === ConnectionState.Disconnected) {\n            this.privConnectionId = null;\n            this.privConnectionPromise = undefined;\n            this.privServiceHasSentMessage = false;\n            return this.connectImpl();\n          }\n\n          return this.privConnectionPromise;\n        }, () => {\n          this.privConnectionId = null;\n          this.privConnectionPromise = undefined;\n          this.privServiceHasSentMessage = false;\n          return this.connectImpl();\n        });\n      }\n\n      this.privConnectionPromise = this.retryableConnect(); // Attach an empty handler to allow the promise to run in the background while\n      // other startup events happen. It'll eventually be awaited on.\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n      this.privConnectionPromise.catch(() => {});\n\n      if (this.postConnectImplOverride !== undefined) {\n        return this.postConnectImplOverride(this.privConnectionPromise);\n      }\n\n      return this.privConnectionPromise;\n    }\n\n    sendSpeechServiceConfig(connection, requestSession, SpeechServiceConfigJson) {\n      requestSession.onSpeechContext(); // filter out anything that is not required for the service to work.\n\n      if (ServiceRecognizerBase.telemetryDataEnabled !== true) {\n        const withTelemetry = JSON.parse(SpeechServiceConfigJson);\n        const replacement = {\n          context: {\n            system: withTelemetry.context.system\n          }\n        };\n        SpeechServiceConfigJson = JSON.stringify(replacement);\n      }\n\n      if (this.privRecognizerConfig.parameters.getProperty(\"TranscriptionService_SingleChannel\", \"false\").toLowerCase() === \"true\") {\n        const json = JSON.parse(SpeechServiceConfigJson);\n        json.context.DisableReferenceChannel = \"True\";\n        json.context.MicSpec = \"1_0_0\";\n        SpeechServiceConfigJson = JSON.stringify(json);\n      }\n\n      if (SpeechServiceConfigJson) {\n        return connection.send(new SpeechConnectionMessage(MessageType.Text, \"speech.config\", requestSession.requestId, \"application/json\", SpeechServiceConfigJson));\n      }\n\n      return;\n    }\n\n    fetchConnection() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (this.privConnectionConfigurationPromise !== undefined) {\n          return this.privConnectionConfigurationPromise.then(connection => {\n            if (connection.state() === ConnectionState.Disconnected) {\n              this.privConnectionId = null;\n              this.privConnectionConfigurationPromise = undefined;\n              this.privServiceHasSentMessage = false;\n              return this.fetchConnection();\n            }\n\n            return this.privConnectionConfigurationPromise;\n          }, () => {\n            this.privConnectionId = null;\n            this.privConnectionConfigurationPromise = undefined;\n            this.privServiceHasSentMessage = false;\n            return this.fetchConnection();\n          });\n        }\n\n        this.privConnectionConfigurationPromise = this.configureConnection();\n        return yield this.privConnectionConfigurationPromise;\n      });\n    }\n\n    sendAudio(audioStreamNode) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const audioFormat = yield this.audioSource.format; // The time we last sent data to the service.\n\n        let nextSendTime = Date.now(); // Max amount to send before we start to throttle\n\n        const fastLaneSizeMs = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-TransmitLengthBeforThrottleMs\", \"5000\");\n        const maxSendUnthrottledBytes = audioFormat.avgBytesPerSec / 1000 * parseInt(fastLaneSizeMs, 10);\n        const startRecogNumber = this.privRequestSession.recogNumber;\n\n        const readAndUploadCycle = () => __awaiter(this, void 0, void 0, function* () {\n          // If speech is done, stop sending audio.\n          if (!this.privIsDisposed && !this.privRequestSession.isSpeechEnded && this.privRequestSession.isRecognizing && this.privRequestSession.recogNumber === startRecogNumber) {\n            const connection = yield this.fetchConnection();\n            const audioStreamChunk = yield audioStreamNode.read(); // we have a new audio chunk to upload.\n\n            if (this.privRequestSession.isSpeechEnded) {\n              // If service already recognized audio end then don't send any more audio\n              return;\n            }\n\n            let payload;\n            let sendDelay;\n\n            if (!audioStreamChunk || audioStreamChunk.isEnd) {\n              payload = null;\n              sendDelay = 0;\n            } else {\n              payload = audioStreamChunk.buffer;\n              this.privRequestSession.onAudioSent(payload.byteLength);\n\n              if (maxSendUnthrottledBytes >= this.privRequestSession.bytesSent) {\n                sendDelay = 0;\n              } else {\n                sendDelay = Math.max(0, nextSendTime - Date.now());\n              }\n            }\n\n            if (0 !== sendDelay) {\n              yield this.delay(sendDelay);\n            }\n\n            if (payload !== null) {\n              nextSendTime = Date.now() + payload.byteLength * 1000 / (audioFormat.avgBytesPerSec * 2);\n            } // Are we still alive?\n\n\n            if (!this.privIsDisposed && !this.privRequestSession.isSpeechEnded && this.privRequestSession.isRecognizing && this.privRequestSession.recogNumber === startRecogNumber) {\n              connection.send(new SpeechConnectionMessage(MessageType.Binary, \"audio\", this.privRequestSession.requestId, null, payload)).catch(() => {\n                // eslint-disable-next-line @typescript-eslint/no-empty-function\n                this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition).catch(() => {});\n              });\n\n              if (!(audioStreamChunk === null || audioStreamChunk === void 0 ? void 0 : audioStreamChunk.isEnd)) {\n                // this.writeBufferToConsole(payload);\n                // Regardless of success or failure, schedule the next upload.\n                // If the underlying connection was broken, the next cycle will\n                // get a new connection and re-transmit missing audio automatically.\n                return readAndUploadCycle();\n              } else {\n                // the audio stream has been closed, no need to schedule next\n                // read-upload cycle.\n                if (!this.privIsLiveAudio) {\n                  this.privRequestSession.onSpeechEnded();\n                }\n              }\n            }\n          }\n        });\n\n        return readAndUploadCycle();\n      });\n    }\n\n    retryableConnect() {\n      return __awaiter(this, void 0, void 0, function* () {\n        let isUnAuthorized = false;\n        this.privAuthFetchEventId = createNoDashGuid();\n        const sessionId = this.privRequestSession.sessionId;\n        this.privConnectionId = sessionId !== undefined ? sessionId : createNoDashGuid();\n        this.privRequestSession.onPreConnectionStart(this.privAuthFetchEventId, this.privConnectionId);\n        let lastStatusCode = 0;\n        let lastReason = \"\";\n\n        while (this.privRequestSession.numConnectionAttempts <= this.privRecognizerConfig.maxRetryCount) {\n          // Get the auth information for the connection. This is a bit of overkill for the current API surface, but leaving the plumbing in place to be able to raise a developer-customer\n          // facing event when a connection fails to let them try and provide new auth information.\n          const authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);\n          const auth = yield authPromise;\n          yield this.privRequestSession.onAuthCompleted(false); // Create the connection\n\n          const connection = this.privConnectionFactory.create(this.privRecognizerConfig, auth, this.privConnectionId); // Attach the telemetry handlers.\n\n          this.privRequestSession.listenForServiceTelemetry(connection.events); // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\n          // it'll stop sending events.\n\n          connection.events.attach(event => {\n            this.connectionEvents.onEvent(event);\n          });\n          const response = yield connection.open(); // 200 == everything is fine.\n\n          if (response.statusCode === 200) {\n            yield this.privRequestSession.onConnectionEstablishCompleted(response.statusCode);\n            return Promise.resolve(connection);\n          } else if (response.statusCode === 1006) {\n            isUnAuthorized = true;\n          }\n\n          lastStatusCode = response.statusCode;\n          lastReason = response.reason;\n          this.privRequestSession.onRetryConnection();\n        }\n\n        yield this.privRequestSession.onConnectionEstablishCompleted(lastStatusCode, lastReason);\n        return Promise.reject(`Unable to contact server. StatusCode: ${lastStatusCode}, ${this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${lastReason}`);\n      });\n    }\n\n    delay(delayMs) {\n      return new Promise(resolve => this.privSetTimeout(resolve, delayMs));\n    }\n\n    writeBufferToConsole(buffer) {\n      let out = \"Buffer Size: \";\n\n      if (null === buffer) {\n        out += \"null\";\n      } else {\n        const readView = new Uint8Array(buffer);\n        out += `${buffer.byteLength}\\r\\n`;\n\n        for (let i = 0; i < buffer.byteLength; i++) {\n          out += readView[i].toString(16).padStart(2, \"0\") + \" \";\n        }\n      } // eslint-disable-next-line no-console\n\n\n      console.info(out);\n    }\n\n    sendFinalAudio() {\n      return __awaiter(this, void 0, void 0, function* () {\n        const connection = yield this.fetchConnection();\n        yield connection.send(new SpeechConnectionMessage(MessageType.Binary, \"audio\", this.privRequestSession.requestId, null, null));\n        return;\n      });\n    } // Takes an established websocket connection to the endpoint and sends speech configuration information.\n\n\n    configureConnection() {\n      return __awaiter(this, void 0, void 0, function* () {\n        const connection = yield this.connectImpl();\n\n        if (this.configConnectionOverride !== undefined) {\n          return this.configConnectionOverride(connection);\n        }\n\n        yield this.sendSpeechServiceConfig(connection, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize());\n        yield this.sendPrePayloadJSON(connection, false);\n        return connection;\n      });\n    }\n\n  }\n\n  ServiceRecognizerBase.telemetryDataEnabled = true; //# sourceMappingURL=ServiceRecognizerBase.js.map\n\n  return ServiceRecognizerBase;\n})();","map":null,"metadata":{},"sourceType":"module"}