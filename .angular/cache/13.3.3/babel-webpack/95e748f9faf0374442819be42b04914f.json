{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { Deferred, MessageType } from \"../common/Exports\";\nimport { CancellationErrorCode, IntentRecognitionCanceledEventArgs, IntentRecognitionEventArgs, IntentRecognitionResult, PropertyCollection, PropertyId, ResultReason } from \"../sdk/Exports\";\nimport { CancellationErrorCodePropertyName, EnumTranslation, IntentResponse, ServiceRecognizerBase, SimpleSpeechPhrase, SpeechHypothesis } from \"./Exports\"; // eslint-disable-next-line max-classes-per-file\n\nexport class IntentServiceRecognizer extends ServiceRecognizerBase {\n  constructor(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {\n    super(authentication, connectionFactory, audioSource, recognizerConfig, recognizer);\n    this.privIntentRecognizer = recognizer;\n    this.privIntentDataSent = false;\n  }\n\n  setIntents(addedIntents, umbrellaIntent) {\n    this.privAddedLmIntents = addedIntents;\n    this.privUmbrellaIntent = umbrellaIntent;\n    this.privIntentDataSent = true;\n  }\n\n  processTypeSpecificMessages(connectionMessage) {\n    let result;\n    let ev;\n    let processed = false;\n    const resultProps = new PropertyCollection();\n\n    if (connectionMessage.messageType === MessageType.Text) {\n      resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\n    }\n\n    switch (connectionMessage.path.toLowerCase()) {\n      case \"speech.hypothesis\":\n        const speechHypothesis = SpeechHypothesis.fromJSON(connectionMessage.textBody);\n        result = new IntentRecognitionResult(undefined, this.privRequestSession.requestId, ResultReason.RecognizingIntent, speechHypothesis.Text, speechHypothesis.Duration, speechHypothesis.Offset + this.privRequestSession.currentTurnAudioOffset, speechHypothesis.Language, speechHypothesis.LanguageDetectionConfidence, undefined, connectionMessage.textBody, resultProps);\n        this.privRequestSession.onHypothesis(result.offset);\n        ev = new IntentRecognitionEventArgs(result, speechHypothesis.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);\n\n        if (!!this.privIntentRecognizer.recognizing) {\n          try {\n            this.privIntentRecognizer.recognizing(this.privIntentRecognizer, ev);\n            /* eslint-disable no-empty */\n          } catch (error) {// Not going to let errors in the event handler\n            // trip things up.\n          }\n        }\n\n        processed = true;\n        break;\n\n      case \"speech.phrase\":\n        const simple = SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\n        result = new IntentRecognitionResult(undefined, this.privRequestSession.requestId, EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus), simple.DisplayText, simple.Duration, simple.Offset + this.privRequestSession.currentTurnAudioOffset, simple.Language, simple.LanguageDetectionConfidence, undefined, connectionMessage.textBody, resultProps);\n        ev = new IntentRecognitionEventArgs(result, result.offset, this.privRequestSession.sessionId);\n\n        const sendEvent = () => {\n          if (!!this.privIntentRecognizer.recognized) {\n            try {\n              this.privIntentRecognizer.recognized(this.privIntentRecognizer, ev);\n              /* eslint-disable no-empty */\n            } catch (error) {// Not going to let errors in the event handler\n              // trip things up.\n            }\n          } // report result to promise.\n\n\n          if (!!this.privSuccessCallback) {\n            try {\n              this.privSuccessCallback(result);\n            } catch (e) {\n              if (!!this.privErrorCallback) {\n                this.privErrorCallback(e);\n              }\n            } // Only invoke the call back once.\n            // and if it's successful don't invoke the\n            // error after that.\n\n\n            this.privSuccessCallback = undefined;\n            this.privErrorCallback = undefined;\n          }\n        }; // If intent data was sent, the terminal result for this recognizer is an intent being found.\n        // If no intent data was sent, the terminal event is speech recognition being successful.\n\n\n        if (false === this.privIntentDataSent || ResultReason.NoMatch === ev.result.reason) {\n          // Advance the buffers.\n          this.privRequestSession.onPhraseRecognized(ev.offset + ev.result.duration);\n          sendEvent();\n        } else {\n          // Squirrel away the args, when the response event arrives it will build upon them\n          // and then return\n          this.privPendingIntentArgs = ev;\n        }\n\n        processed = true;\n        break;\n\n      case \"response\":\n        // Response from LUIS\n        ev = this.privPendingIntentArgs;\n        this.privPendingIntentArgs = undefined;\n\n        if (undefined === ev) {\n          if (\"\" === connectionMessage.textBody) {\n            // This condition happens if there is nothing but silence in the\n            // audio sent to the service.\n            return;\n          } // Odd... Not sure this can happen\n\n\n          ev = new IntentRecognitionEventArgs(new IntentRecognitionResult(), 0, this.privRequestSession.sessionId);\n        }\n\n        const intentResponse = IntentResponse.fromJSON(connectionMessage.textBody); // If LUIS didn't return anything, send the existing event, else\n        // modify it to show the match.\n        // See if the intent found is in the list of intents asked for.\n\n        let addedIntent = this.privAddedLmIntents[intentResponse.topScoringIntent.intent];\n\n        if (this.privUmbrellaIntent !== undefined) {\n          addedIntent = this.privUmbrellaIntent;\n        }\n\n        if (null !== intentResponse && addedIntent !== undefined) {\n          const intentId = addedIntent.intentName === undefined ? intentResponse.topScoringIntent.intent : addedIntent.intentName;\n          let reason = ev.result.reason;\n\n          if (undefined !== intentId) {\n            reason = ResultReason.RecognizedIntent;\n          } // make sure, properties is set.\n\n\n          const properties = undefined !== ev.result.properties ? ev.result.properties : new PropertyCollection();\n          properties.setProperty(PropertyId.LanguageUnderstandingServiceResponse_JsonResult, connectionMessage.textBody);\n          ev = new IntentRecognitionEventArgs(new IntentRecognitionResult(intentId, ev.result.resultId, reason, ev.result.text, ev.result.duration, ev.result.offset, undefined, undefined, ev.result.errorDetails, ev.result.json, properties), ev.offset, ev.sessionId);\n        }\n\n        this.privRequestSession.onPhraseRecognized(ev.offset + ev.result.duration);\n\n        if (!!this.privIntentRecognizer.recognized) {\n          try {\n            this.privIntentRecognizer.recognized(this.privIntentRecognizer, ev);\n            /* eslint-disable no-empty */\n          } catch (error) {// Not going to let errors in the event handler\n            // trip things up.\n          }\n        } // report result to promise.\n\n\n        if (!!this.privSuccessCallback) {\n          try {\n            this.privSuccessCallback(ev.result);\n          } catch (e) {\n            if (!!this.privErrorCallback) {\n              this.privErrorCallback(e);\n            }\n          } // Only invoke the call back once.\n          // and if it's successful don't invoke the\n          // error after that.\n\n\n          this.privSuccessCallback = undefined;\n          this.privErrorCallback = undefined;\n        }\n\n        processed = true;\n        break;\n\n      default:\n        break;\n    }\n\n    const defferal = new Deferred();\n    defferal.resolve(processed);\n    return defferal.promise;\n  } // Cancels recognition.\n\n\n  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n    const properties = new PropertyCollection();\n    properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\n\n    if (!!this.privIntentRecognizer.canceled) {\n      const cancelEvent = new IntentRecognitionCanceledEventArgs(cancellationReason, error, errorCode, undefined, undefined, sessionId);\n\n      try {\n        this.privIntentRecognizer.canceled(this.privIntentRecognizer, cancelEvent);\n        /* eslint-disable no-empty */\n      } catch (_a) {}\n    }\n\n    if (!!this.privSuccessCallback) {\n      const result = new IntentRecognitionResult(undefined, // Intent Id\n      requestId, ResultReason.Canceled, undefined, // Text\n      undefined, // Duration\n      undefined, // Offset\n      undefined, // Language\n      undefined, // LanguageDetectionConfidence\n      error, undefined, // Json\n      properties);\n\n      try {\n        this.privSuccessCallback(result);\n        this.privSuccessCallback = undefined;\n        /* eslint-disable no-empty */\n      } catch (_b) {}\n    }\n  }\n\n} //# sourceMappingURL=IntentServiceRecognizer.js.map","map":null,"metadata":{},"sourceType":"module"}