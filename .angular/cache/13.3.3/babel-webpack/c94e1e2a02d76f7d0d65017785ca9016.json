{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport bent from \"bent\";\nimport { ArgumentNullError, Deferred } from \"../common/Exports\";\nexport var RestRequestType = /*#__PURE__*/(() => {\n  (function (RestRequestType) {\n    RestRequestType[\"Get\"] = \"GET\";\n    RestRequestType[\"Post\"] = \"POST\";\n    RestRequestType[\"Delete\"] = \"DELETE\";\n    RestRequestType[\"File\"] = \"file\";\n  })(RestRequestType || (RestRequestType = {}));\n\n  return RestRequestType;\n})();\n// accept rest operations via request method and return abstracted objects from server response\nexport class RestMessageAdapter {\n  constructor(configParams) {\n    if (!configParams) {\n      throw new ArgumentNullError(\"configParams\");\n    }\n\n    this.privHeaders = configParams.headers;\n    this.privIgnoreCache = configParams.ignoreCache;\n  }\n\n  static extractHeaderValue(headerKey, headers) {\n    let headerValue = \"\";\n\n    try {\n      const arr = headers.trim().split(/[\\r\\n]+/);\n      const headerMap = {};\n      arr.forEach(line => {\n        const parts = line.split(\": \");\n        const header = parts.shift().toLowerCase();\n        const value = parts.join(\": \");\n        headerMap[header] = value;\n      });\n      headerValue = headerMap[headerKey.toLowerCase()];\n    } catch (e) {// ignore the error\n    }\n\n    return headerValue;\n  }\n\n  set options(configParams) {\n    this.privHeaders = configParams.headers;\n    this.privIgnoreCache = configParams.ignoreCache;\n  }\n\n  setHeaders(key, value) {\n    this.privHeaders[key] = value;\n  }\n\n  request(method, uri, queryParams = {}, body = null, binaryBody = null) {\n    const responseReceivedDeferral = new Deferred();\n    const requestCommand = method === RestRequestType.File ? \"POST\" : method;\n\n    const handleRestResponse = (data, j = {}) => {\n      const d = data;\n      return {\n        data: JSON.stringify(j),\n        headers: JSON.stringify(data.headers),\n        json: j,\n        ok: data.statusCode >= 200 && data.statusCode < 300,\n        status: data.statusCode,\n        statusText: j.error ? j.error.message : d.statusText ? d.statusText : d.statusMessage\n      };\n    };\n\n    const blobToArrayBuffer = blob => {\n      const reader = new FileReader();\n      reader.readAsArrayBuffer(blob);\n      return new Promise(resolve => {\n        reader.onloadend = () => {\n          resolve(reader.result);\n        };\n      });\n    };\n\n    const send = postData => {\n      const sendRequest = bent(uri, requestCommand, this.privHeaders, 200, 201, 202, 204, 400, 401, 402, 403, 404);\n      const params = this.queryParams(queryParams) === \"\" ? \"\" : `?${this.queryParams(queryParams)}`;\n      sendRequest(params, postData).then(data => __awaiter(this, void 0, void 0, function* () {\n        if (method === RestRequestType.Delete || data.statusCode === 204) {\n          // No JSON from Delete and reset (204) operations\n          responseReceivedDeferral.resolve(handleRestResponse(data));\n        } else {\n          try {\n            const j = yield data.json();\n            responseReceivedDeferral.resolve(handleRestResponse(data, j));\n          } catch (_a) {\n            responseReceivedDeferral.resolve(handleRestResponse(data));\n          }\n        }\n      })).catch(error => {\n        responseReceivedDeferral.reject(error);\n      });\n    };\n\n    if (this.privIgnoreCache) {\n      this.privHeaders[\"Cache-Control\"] = \"no-cache\";\n    }\n\n    if (method === RestRequestType.File && binaryBody) {\n      const contentType = \"multipart/form-data\";\n      this.privHeaders[\"content-type\"] = contentType;\n      this.privHeaders[\"Content-Type\"] = contentType;\n\n      if (typeof Blob !== \"undefined\" && binaryBody instanceof Blob) {\n        blobToArrayBuffer(binaryBody).then(res => {\n          send(res);\n        }).catch(error => {\n          responseReceivedDeferral.reject(error);\n        });\n      } else {\n        send(binaryBody);\n      }\n    } else {\n      if (method === RestRequestType.Post && body) {\n        this.privHeaders[\"content-type\"] = \"application/json\";\n        this.privHeaders[\"Content-Type\"] = \"application/json\";\n      }\n\n      send(body);\n    }\n\n    return responseReceivedDeferral.promise;\n  }\n\n  withQuery(url, params = {}) {\n    const queryString = this.queryParams(params);\n    return queryString ? url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + queryString : url;\n  }\n\n  queryParams(params = {}) {\n    return Object.keys(params).map(k => encodeURIComponent(k) + \"=\" + encodeURIComponent(params[k])).join(\"&\");\n  }\n\n} //# sourceMappingURL=RestMessageAdapter.js.map","map":null,"metadata":{},"sourceType":"module"}