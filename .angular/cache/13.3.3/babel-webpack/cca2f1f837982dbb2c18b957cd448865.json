{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ConnectionState, createNoDashGuid, Deferred, MessageType } from \"../../common/Exports\";\nimport { CancellationErrorCode, CancellationReason, ConversationExpirationEventArgs, ConversationTranslationCanceledEventArgs, ConversationTranslationResult, Translations } from \"../../sdk/Exports\";\nimport { CognitiveTokenAuthentication, ServiceRecognizerBase } from \"../Exports\";\nimport { ConversationConnectionMessage } from \"./ConversationConnectionMessage\";\nimport { ConversationRequestSession } from \"./ConversationRequestSession\";\nimport { ConversationReceivedTranslationEventArgs, LockRoomEventArgs, MuteAllEventArgs, ParticipantAttributeEventArgs, ParticipantEventArgs, ParticipantsListEventArgs } from \"./ConversationTranslatorEventArgs\";\nimport { ConversationTranslatorCommandTypes, ConversationTranslatorMessageTypes } from \"./ConversationTranslatorInterfaces\";\nimport { CommandResponsePayload, ParticipantPayloadResponse, ParticipantsListPayloadResponse, SpeechResponsePayload, TextResponsePayload } from \"./ServiceMessages/Exports\";\n/**\n * The service adapter handles sending and receiving messages to the Conversation Translator websocket.\n */\n\nexport class ConversationServiceAdapter extends ServiceRecognizerBase {\n  constructor(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector) {\n    super(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector);\n    this.privConnectionConfigPromise = undefined;\n    this.privLastPartialUtteranceId = \"\";\n    this.privConversationServiceConnector = conversationServiceConnector;\n    this.privConversationAuthentication = authentication;\n\n    this.receiveMessageOverride = () => this.receiveConversationMessageOverride();\n\n    this.recognizeOverride = () => this.noOp();\n\n    this.postConnectImplOverride = connection => this.conversationConnectImpl(connection);\n\n    this.configConnectionOverride = () => this.configConnection();\n\n    this.disconnectOverride = () => this.privDisconnect();\n\n    this.privConversationRequestSession = new ConversationRequestSession(createNoDashGuid());\n    this.privConversationConnectionFactory = connectionFactory;\n    this.privConversationIsDisposed = false;\n  }\n\n  isDisposed() {\n    return super.isDisposed() || this.privConversationIsDisposed;\n  }\n\n  dispose(reason) {\n    const _super = Object.create(null, {\n      dispose: {\n        get: () => super.dispose\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privConversationIsDisposed = true;\n\n      if (this.privConnectionConfigPromise !== undefined) {\n        const connection = yield this.privConnectionConfigPromise;\n        yield connection.dispose(reason);\n      }\n\n      yield _super.dispose.call(this, reason);\n    });\n  }\n\n  sendMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.fetchConnection();\n      return connection.send(new ConversationConnectionMessage(MessageType.Text, message));\n    });\n  }\n\n  sendMessageAsync(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.fetchConnection();\n      yield connection.send(new ConversationConnectionMessage(MessageType.Text, message));\n    });\n  }\n\n  privDisconnect() {\n    if (this.terminateMessageLoop) {\n      return;\n    }\n\n    this.cancelRecognition(this.privConversationRequestSession.sessionId, this.privConversationRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.NoError, \"Disconnecting\");\n    this.terminateMessageLoop = true;\n    return Promise.resolve();\n  } // eslint-disable-next-line @typescript-eslint/require-await\n\n\n  processTypeSpecificMessages() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return true;\n    });\n  } // Cancels recognition.\n\n\n  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n    this.terminateMessageLoop = true;\n    const cancelEvent = new ConversationTranslationCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);\n\n    try {\n      if (!!this.privConversationServiceConnector.canceled) {\n        this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, cancelEvent);\n      }\n    } catch (_a) {// continue on error\n    }\n  }\n\n  noOp() {\n    // operation not supported\n    return;\n  }\n  /**\n   * Establishes a websocket connection to the end point.\n   */\n\n\n  conversationConnectImpl(connection) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privConnectionLoop = this.startMessageLoop();\n      return connection;\n    });\n  }\n  /**\n   * Process incoming websocket messages\n   */\n\n\n  receiveConversationMessageOverride() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.isDisposed() || this.terminateMessageLoop) {\n        return Promise.resolve();\n      } // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\n\n\n      const communicationCustodian = new Deferred();\n\n      try {\n        const connection = yield this.fetchConnection();\n        const message = yield connection.read();\n\n        if (this.isDisposed() || this.terminateMessageLoop) {\n          // We're done.\n          communicationCustodian.resolve();\n          return Promise.resolve();\n        }\n\n        if (!message) {\n          return this.receiveConversationMessageOverride();\n        }\n\n        const sessionId = this.privConversationRequestSession.sessionId;\n        let sendFinal = false;\n\n        try {\n          switch (message.conversationMessageType.toLowerCase()) {\n            case \"info\":\n            case \"participant_command\":\n            case \"command\":\n              const commandPayload = CommandResponsePayload.fromJSON(message.textBody);\n\n              switch (commandPayload.command.toLowerCase()) {\n                /**\n                 * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.\n                 * The consuming client must wait for this message to arrive\n                 * before starting to send their own data.\n                 */\n                case \"participantlist\":\n                  const participantsPayload = ParticipantsListPayloadResponse.fromJSON(message.textBody);\n                  const participantsResult = participantsPayload.participants.map(p => {\n                    const participant = {\n                      avatar: p.avatar,\n                      displayName: p.nickname,\n                      id: p.participantId,\n                      isHost: p.ishost,\n                      isMuted: p.ismuted,\n                      isUsingTts: p.usetts,\n                      preferredLanguage: p.locale\n                    };\n                    return participant;\n                  });\n\n                  if (!!this.privConversationServiceConnector.participantsListReceived) {\n                    this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector, new ParticipantsListEventArgs(participantsPayload.roomid, participantsPayload.token, participantsPayload.translateTo, participantsPayload.profanityFilter, participantsPayload.roomProfanityFilter, participantsPayload.roomLocked, participantsPayload.muteAll, participantsResult, sessionId));\n                  }\n\n                  break;\n\n                /**\n                 * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).\n                 * This is sent at the start of the Conversation\n                 */\n\n                case \"settranslatetolanguages\":\n                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setTranslateToLanguages, commandPayload.value, sessionId));\n                  }\n\n                  break;\n\n                /**\n                 * 'SetProfanityFiltering' lets the client set the level of profanity filtering.\n                 * If sent by the participant the setting will effect only their own profanity level.\n                 * If sent by the host, the setting will effect all participants including the host.\n                 * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'\n                 */\n\n                case \"setprofanityfiltering\":\n                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setProfanityFiltering, commandPayload.value, sessionId));\n                  }\n\n                  break;\n\n                /**\n                 * 'SetMute' is sent if the participant has been muted by the host.\n                 * Check the 'participantId' to determine if the current user has been muted.\n                 */\n\n                case \"setmute\":\n                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setMute, commandPayload.value, sessionId));\n                  }\n\n                  break;\n\n                /**\n                 * 'SetMuteAll' is sent if the Conversation has been muted by the host.\n                 */\n\n                case \"setmuteall\":\n                  if (!!this.privConversationServiceConnector.muteAllCommandReceived) {\n                    this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector, new MuteAllEventArgs(commandPayload.value, sessionId));\n                  }\n\n                  break;\n\n                /**\n                 * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.\n                 */\n\n                case \"roomexpirationwarning\":\n                  if (!!this.privConversationServiceConnector.conversationExpiration) {\n                    this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector, new ConversationExpirationEventArgs(commandPayload.value, this.privConversationRequestSession.sessionId));\n                  }\n\n                  break;\n\n                /**\n                 * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.\n                 */\n\n                case \"setusetts\":\n                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setUseTTS, commandPayload.value, sessionId));\n                  }\n\n                  break;\n\n                /**\n                 * 'SetLockState' is set if the host has locked or unlocked the Conversation.\n                 */\n\n                case \"setlockstate\":\n                  if (!!this.privConversationServiceConnector.lockRoomCommandReceived) {\n                    this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector, new LockRoomEventArgs(commandPayload.value, sessionId));\n                  }\n\n                  break;\n\n                /**\n                 * 'ChangeNickname' is received if a user changes their display name.\n                 * Any cached particpiants list should be updated to reflect the display name.\n                 */\n\n                case \"changenickname\":\n                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.changeNickname, commandPayload.nickname, sessionId));\n                  }\n\n                  break;\n\n                /**\n                 * 'JoinSession' is sent when a user joins the Conversation.\n                 */\n\n                case \"joinsession\":\n                  const joinParticipantPayload = ParticipantPayloadResponse.fromJSON(message.textBody);\n                  const joiningParticipant = {\n                    avatar: joinParticipantPayload.avatar,\n                    displayName: joinParticipantPayload.nickname,\n                    id: joinParticipantPayload.participantId,\n                    isHost: joinParticipantPayload.ishost,\n                    isMuted: joinParticipantPayload.ismuted,\n                    isUsingTts: joinParticipantPayload.usetts,\n                    preferredLanguage: joinParticipantPayload.locale\n                  };\n\n                  if (!!this.privConversationServiceConnector.participantJoinCommandReceived) {\n                    this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector, new ParticipantEventArgs(joiningParticipant, sessionId));\n                  }\n\n                  break;\n\n                /**\n                 * 'LeaveSession' is sent when a user leaves the Conversation'.\n                 */\n\n                case \"leavesession\":\n                  const leavingParticipant = {\n                    id: commandPayload.participantId\n                  };\n\n                  if (!!this.privConversationServiceConnector.participantLeaveCommandReceived) {\n                    this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector, new ParticipantEventArgs(leavingParticipant, sessionId));\n                  }\n\n                  break;\n\n                /**\n                 * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).\n                 * Check the 'ParticipantId' to check whether the message is for the current user.\n                 */\n\n                case \"disconnectsession\":\n                  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                  const disconnectParticipant = {\n                    id: commandPayload.participantId\n                  };\n                  break;\n\n                case \"token\":\n                  const token = new CognitiveTokenAuthentication(() => {\n                    const authorizationToken = commandPayload.token;\n                    return Promise.resolve(authorizationToken);\n                  }, () => {\n                    const authorizationToken = commandPayload.token;\n                    return Promise.resolve(authorizationToken);\n                  });\n                  this.authentication = token;\n                  break;\n\n                /**\n                 * Message not recognized.\n                 */\n\n                default:\n                  break;\n              }\n\n              break;\n\n            /**\n             * 'partial' (or 'hypothesis') represents a unfinalized speech message.\n             */\n\n            case \"partial\":\n            /**\n             * 'final' (or 'phrase') represents a finalized speech message.\n             */\n\n            case \"final\":\n              const speechPayload = SpeechResponsePayload.fromJSON(message.textBody);\n              const speechResult = new ConversationTranslationResult(speechPayload.participantId, this.getTranslations(speechPayload.translations), speechPayload.language, undefined, undefined, speechPayload.recognition, undefined, undefined, message.textBody, undefined);\n\n              if (speechPayload.isFinal) {\n                // check the length, sometimes empty finals are returned\n                if (speechResult.text !== undefined && speechResult.text.length > 0) {\n                  sendFinal = true;\n                } else if (speechPayload.id === this.privLastPartialUtteranceId) {\n                  // send final as normal. We had a non-empty partial for this same utterance\n                  // so sending the empty final is important\n                  sendFinal = true;\n                } else {// suppress unneeded final\n                }\n\n                if (sendFinal) {\n                  if (!!this.privConversationServiceConnector.translationReceived) {\n                    this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.final, speechResult, sessionId));\n                  }\n                }\n              } else if (speechResult.text !== undefined) {\n                this.privLastPartialUtteranceId = speechPayload.id;\n\n                if (!!this.privConversationServiceConnector.translationReceived) {\n                  this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.partial, speechResult, sessionId));\n                }\n              }\n\n              break;\n\n            /**\n             * \"translated_message\" is a text message or instant message (IM).\n             */\n\n            case \"translated_message\":\n              const textPayload = TextResponsePayload.fromJSON(message.textBody);\n              const textResult = new ConversationTranslationResult(textPayload.participantId, this.getTranslations(textPayload.translations), textPayload.language, undefined, undefined, textPayload.originalText, undefined, undefined, undefined, message.textBody, undefined);\n\n              if (!!this.privConversationServiceConnector.translationReceived) {\n                this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.instantMessage, textResult, sessionId));\n              }\n\n              break;\n\n            default:\n              // ignore any unsupported message types\n              break;\n          }\n        } catch (e) {// continue\n        }\n\n        return this.receiveConversationMessageOverride();\n      } catch (e) {\n        this.terminateMessageLoop = true;\n      }\n\n      return communicationCustodian.promise;\n    });\n  }\n\n  startMessageLoop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.isDisposed()) {\n        return Promise.resolve();\n      }\n\n      this.terminateMessageLoop = false;\n      const messageRetrievalPromise = this.receiveConversationMessageOverride();\n\n      try {\n        const r = yield messageRetrievalPromise;\n        return r;\n      } catch (error) {\n        this.cancelRecognition(this.privRequestSession ? this.privRequestSession.sessionId : \"\", this.privRequestSession ? this.privRequestSession.requestId : \"\", CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\n        return null;\n      }\n    });\n  } // Takes an established websocket connection to the endpoint\n\n\n  configConnection() {\n    if (this.isDisposed()) {\n      return Promise.resolve(undefined);\n    }\n\n    if (this.privConnectionConfigPromise !== undefined) {\n      return this.privConnectionConfigPromise.then(connection => {\n        if (connection.state() === ConnectionState.Disconnected) {\n          this.privConnectionId = null;\n          this.privConnectionConfigPromise = undefined;\n          return this.configConnection();\n        }\n\n        return this.privConnectionConfigPromise;\n      }, () => {\n        this.privConnectionId = null;\n        this.privConnectionConfigPromise = undefined;\n        return this.configConnection();\n      });\n    }\n\n    if (this.terminateMessageLoop) {\n      return Promise.resolve(undefined);\n    }\n\n    this.privConnectionConfigPromise = this.connectImpl().then(connection => connection);\n    return this.privConnectionConfigPromise;\n  }\n\n  getTranslations(serviceResultTranslations) {\n    let translations;\n\n    if (undefined !== serviceResultTranslations) {\n      translations = new Translations();\n\n      for (const translation of serviceResultTranslations) {\n        translations.set(translation.lang, translation.translation);\n      }\n    }\n\n    return translations;\n  }\n\n} //# sourceMappingURL=ConversationServiceAdapter.js.map","map":null,"metadata":{},"sourceType":"module"}